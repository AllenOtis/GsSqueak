'From Squeak5.1 of 15 October 2017 [latest update: #16550] on 16 January 2018 at 3:53:48 pm'!DisplayMedium subclass: #Form	instanceVariableNames: 'bits width height depth offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!Form commentStamp: 'ls 1/4/2004 17:16' prior: 0!A rectangular array of pixels, used for holding images.  All pictures, including character images are Forms.  The depth of a Form is how many bits are used to specify the color at each pixel.  The actual bits are held in a Bitmap, whose internal structure is different at each depth.  Class Color allows you to deal with colors without knowing how they are actually encoded inside a Bitmap.	  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.	Forms are indexed starting at 0 instead of 1; thus, the top-left pixel of a Form has coordinates 0@0.	Forms are combined using BitBlt.  See the comment in class BitBlt.  Forms that repeat many times to fill a large destination are InfiniteForms.	colorAt: x@y		Returns the abstract Color at this location	displayAt: x@y		shows this form on the screen	displayOn: aMedium at: x@y	shows this form in a Window, a Form, or other DisplayMedium	fillColor: aColor		Set all the pixels to the color.	edit		launch an editor to change the bits of this form.	pixelValueAt: x@y	The encoded color.  The encoding depends on the depth.!!Form methodsFor: '*Etoys-testing' stamp: 'RAA 1/19/2001 15:04'!appearsToBeSameCostumeAs: anotherForm 	(anotherForm isKindOf: self class)		ifFalse: [^ false].	anotherForm depth = self depth		ifFalse: [^ false].	^ anotherForm bits = bits! !!Form methodsFor: '*Morphic' stamp: 'ar 11/7/1999 20:29'!asMorph	^ ImageMorph new image: self! !!Form methodsFor: '*Morphic' stamp: 'ar 7/8/2006 21:01'!iconOrThumbnailOfSize: aNumberOrPoint 	"Answer an appropiate form to represent the receiver"	^ self scaledIntoFormOfSize: aNumberOrPoint! !!Form methodsFor: '*Morphic' stamp: 'mt 8/25/2015 10:43'!scaledIntoFormOfSize: aNumberOrPoint 	^ self scaledIntoFormOfSize: aNumberOrPoint smoothing: 8! !!Form methodsFor: '*Morphic' stamp: 'mt 12/10/2015 09:43'!scaledIntoFormOfSize: aNumberOrPoint smoothing: factor 	"Scale and center the receiver into a form of a given size"	| extent scaledForm result |	extent := aNumberOrPoint asPoint.	extent = self extent		ifTrue: [^ self copy].	scaledForm := self scaledToSize: extent smoothing: factor.	result := self species extent: extent depth: self depth.	result getCanvas translucentImage: scaledForm at: extent - scaledForm extent // 2.	^ result! !!Form methodsFor: '*Morphic-Support-image manipulation' stamp: 'LB 8/26/2002 18:08'!stencil	"return a 1-bit deep, black-and-white stencil of myself"	| canvas |	canvas := FormCanvas extent: self extent depth: 1.	canvas fillColor: Color white.	canvas		stencil: self		at: 0 @ 0		sourceRect: (Rectangle origin: 0 @ 0 corner: self extent)		color: Color black.	^ canvas form! !!Form methodsFor: '*MorphicExtras-other' stamp: 'sw 5/3/2001 16:23'!graphicForViewerTab	"Answer the graphic to be used in the tab of a viewer open on me"	^ self! !!Form methodsFor: '*MorphicExtras-postscript generation' stamp: 'RAA 4/20/2001 15:40'!encodePostscriptOn: aStream 	self unhibernate.	"since current Postscript support treats 8-bit forms as 0 to 255 gray	scale, convert	to 16 first so we get more faithful results"	self depth <= 8		ifTrue: [^ (self asFormOfDepth: 16)				encodePostscriptOn: aStream].	^ self		printPostscript: aStream		operator: (self depth = 1				ifTrue: ['imagemask']				ifFalse: ['image'])! !!Form methodsFor: '*nebraska-encoding' stamp: 'RAA 7/29/2000 09:01'!addDeltasFrom: previousForm 	(BitBlt		destForm: self		sourceForm: previousForm		fillColor: nil		combinationRule: Form reverse		destOrigin: 0 @ 0		sourceOrigin: 0 @ 0		extent: self extent		clipRect: self boundingBox) copyBits! !!Form methodsFor: '*nebraska-encoding' stamp: 'RAA 7/29/2000 09:01'!deltaFrom: previousForm 	| newForm |	newForm := previousForm deepCopy.	(BitBlt		destForm: newForm		sourceForm: self		fillColor: nil		combinationRule: Form reverse		destOrigin: 0 @ 0		sourceOrigin: 0 @ 0		extent: self extent		clipRect: self boundingBox) copyBits.	^ newForm! !!Form methodsFor: '*nebraska-encoding' stamp: 'RAA 8/1/2000 06:15'!deltaFrom: smallerForm at: offsetInMe 	| newForm |	newForm := smallerForm deepCopy.	(BitBlt		destForm: newForm		sourceForm: self		fillColor: nil		combinationRule: Form reverse		destOrigin: 0 @ 0		sourceOrigin: offsetInMe		extent: smallerForm extent		clipRect: newForm boundingBox) copyBits.	^ newForm! !!Form methodsFor: '*nebraska-encoding' stamp: 'RAA 8/13/2000 15:32'!encodeForRemoteCanvas	"encode into a bitstream for use with RemoteCanvas. The format does	not require invoking the Compiler"	| header binaryForm |	header := String				streamContents: [:str | "nextPutAll: 'F|';"					str nextPutAll: self depth printString;						 nextPut: $,;						 nextPutAll: self width printString;						 nextPut: $,;						 nextPutAll: self height printString;						 nextPut: $|].	binaryForm := ByteArray				streamContents: [:str | 					self unhibernate.					bits writeOn: str].	^ header , binaryForm asString! !!Form methodsFor: '*vivide' stamp: 'mt 8/15/2012 15:45:29.847'!acceptObjectService: anObjectService 	^ anObjectService doForm: self! !!Form methodsFor: '*widgets-support' stamp: 'mt 9/2/2010 11:52:12.191'!asGrayScale2	^ self		collectColors: [:c | c isTransparent				ifTrue: [c]				ifFalse: [Color gray: c luminance]]! !!Form methodsFor: '*widgets-support' stamp: 'mt 8/16/2012 16:28:27.096'!asWireframe	^ self		collectColors: [:c | Color black alpha: c alpha]! !!Form methodsFor: '*widgets-support' stamp: 'mt 8/21/2012 09:30:25.257'!asWireframeSunken	^ self asWireframeSunken: 0.4! !!Form methodsFor: '*widgets-support' stamp: 'mt 8/22/2012 10:42:36.583'!asWireframeSunken2	| bw hi t |	bw := self				collectColors: [:c | (Color gray: 0.8)						alpha: c alpha].	hi := self				collectColors: [:c | (Color gray: 0.1)						alpha: c alpha].	t := (Form extent: bw extent depth: bw depth)				fillColor: Color transparent.	t		copy: (0 @ 0 extent: hi extent)		from: hi		to: 0 @ -1		rule: Form paint;				copy: (0 @ 0 extent: bw extent)		from: bw		to: 0 @ 0		rule: Form paint.	^ t! !!Form methodsFor: '*widgets-support' stamp: 'mt 8/21/2012 09:24:31.943'!asWireframeSunken: grayValue 	| bw hi t |	bw := self				collectColors: [:c | (Color gray: grayValue)						alpha: c alpha].	hi := self				collectColors: [:c | Color white alpha: c alpha].	t := (Form extent: bw extent depth: bw depth)				fillColor: Color transparent.	t		copy: (0 @ 0 extent: hi extent)		from: hi		to: 0 @ 1		rule: Form paint;				copy: (0 @ 0 extent: bw extent)		from: bw		to: 0 @ 0		rule: Form paint.	^ t! !!Form methodsFor: '*widgets-support' stamp: 'mt 8/16/2012 14:35:03.067'!muchLighter	^ self		collectColors: [:color | color adjustBrightness: 0.4]! !!Form methodsFor: 'accessing'!bits	"Answer the receiver's Bitmap containing its bits."	^ bits! !!Form methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:41'!bitsSize	| pixPerWord |	depth == nil		ifTrue: [depth := 1].	pixPerWord := 32 // self depth.	^ width + pixPerWord - 1 // pixPerWord * height! !!Form methodsFor: 'accessing'!bits: aBitmap 	"Reset the Bitmap containing the receiver's bits."	bits := aBitmap! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 12:03'!defaultCanvasClass	"Return the default canvas used for drawing onto the receiver"	^ Display defaultCanvasClass! !!Form methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45'!depth	^ depth < 0		ifTrue: [0 - depth]		ifFalse: [depth]! !!Form methodsFor: 'accessing'!depth: bitsPerPixel 	(bitsPerPixel > 32			or: [(bitsPerPixel bitAnd: bitsPerPixel - 1)					~= 0])		ifTrue: [self halt: 'bitsPerPixel must be 1, 2, 4, 8, 16 or 32'].	depth := bitsPerPixel! !!Form methodsFor: 'accessing' stamp: 'ar 5/27/2000 16:56'!displayScreen	"Return the display screen the receiver is allocated on. 	Forms in general are Squeak internal and not allocated on any	particular display."	^ nil! !!Form methodsFor: 'accessing'!extent	^ width @ height! !!Form methodsFor: 'accessing'!form	"Answer the receiver's form. For vanilla Forms, this degenerates to self.	Makes several methods that operate on both Forms and MaskedForms	much more straightforward. 6/1/96 sw"	^ self! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 12:03'!getCanvas	"Return a Canvas that can be used to draw onto the receiver"	^ self defaultCanvasClass on: self! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 00:48'!hasBeenModified	"Return true if something *might* have been drawn into the receiver"	^ (bits == nil		or: [bits class == ByteArray]) not"Read the above as: If the receiver has forgotten its contents (bits ==	nil) 	or is still hibernated it can't be modified."! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 00:48'!hasBeenModified: aBool 	"Change the receiver to reflect the modification state"	aBool		ifTrue: [^ self unhibernate].	self shouldPreserveContents		ifTrue: [self hibernate]		ifFalse: [bits := nil]! !!Form methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:50'!nativeDepth	"Return the 'native' depth of the receiver, e.g., including the endianess"	^ depth! !!Form methodsFor: 'accessing' stamp: 'ar 2/16/2000 22:00'!offset	^ offset		ifNil: [0 @ 0]! !!Form methodsFor: 'accessing'!offset: aPoint 	offset := aPoint! !!Form methodsFor: 'accessing'!size	"Should no longer be used -- use bitsSize instead. length of variable	part of instance."	^ super size! !!Form methodsFor: 'analyzing' stamp: 'nice 12/27/2009 03:10'!cgForPixelValue: pv orNot: not 	"Return the center of gravity for all pixels of value pv.	Note: If orNot is true, then produce the center of gravity for all pixels	that are DIFFERENT from the supplied (background) value"	| xAndY |	xAndY := (Array				with: (self xTallyPixelValue: pv orNot: not)				with: (self yTallyPixelValue: pv orNot: not))				collect: [:profile | 					| pixCount weighted |					"For both x and y profiles..."					pixCount := 0.					weighted := 0.					profile						doWithIndex: [:t :i | 							pixCount := pixCount + t.							weighted := weighted + (t * i)].					pixCount = 0						ifTrue: ["Produce average of nPixels weighted by							coordinate "							0.0]						ifFalse: [weighted asFloat / pixCount asFloat - 1.0]].	^ xAndY first @ xAndY last"	| f cg |	[Sensor anyButtonPressed] whileFalse:	[f := Form fromDisplay: (Sensor cursorPoint extent: 50@50).	cg := f cgForPixelValue: (Color black pixelValueForDepth: f depth)	orNot: false.	f displayAt: 0@0.	Display fill: (cg extent: 2@2) fillColor: Color red].	ScheduledControllers restor	"! !!Form methodsFor: 'analyzing' stamp: 'jm 12/5/97 19:48'!colorsUsed	"Return a list of the Colors this form uses."	| tallies tallyDepth usedColors |	tallies := self tallyPixelValues.	tallyDepth := (tallies size log: 2) asInteger.	usedColors := OrderedCollection new.	tallies		doWithIndex: [:count :i | count > 0				ifTrue: [usedColors						add: (Color colorFromPixelValue: i - 1 depth: tallyDepth)]].	^ usedColors asArray! !!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40'!dominantColor	| tally max maxi |	self depth > 16		ifTrue: [^ (self asFormOfDepth: 16) dominantColor].	tally := self tallyPixelValues.	max := maxi := 0.	tally		withIndexDo: [:n :i | n > max				ifTrue: [max := n.					maxi := i]].	^ Color colorFromPixelValue: maxi - 1 depth: self depth! !!Form methodsFor: 'analyzing'!innerPixelRectFor: pv orNot: not 	"Return a rectangle describing the smallest part of me that includes 	all pixels of value pv.	Note: If orNot is true, then produce a copy that includes all pixels	that are DIFFERENT from the supplied (background) value"	| xTally yTally |	xTally := self xTallyPixelValue: pv orNot: not.	yTally := self yTallyPixelValue: pv orNot: not.	^ (xTally		findFirst: [:t | t > 0])		- 1 @ ((yTally			findFirst: [:t | t > 0])			- 1) corner: (xTally			findLast: [:t | t > 0])			@ (yTally					findLast: [:t | t > 0])! !!Form methodsFor: 'analyzing' stamp: 'tpr 3/15/2013 12:27'!pixelCompare: aRect with: otherForm at: otherLoc 	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom. Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord := 32 // self depth.	(aRect left \\ pixPerWord = 0			and: [aRect right \\ pixPerWord = 0])		ifTrue: ["If word-aligned, use on-the-fly difference"			^ (BitBlt toForm: self)				copy: aRect				from: otherLoc				in: otherForm				fillColor: nil				rule: 32].	"Otherwise, combine in a word-sized form and then compute	difference "	temp := self copy: aRect.	temp		copy: aRect		from: otherLoc		in: otherForm		rule: 21.	^ (BitBlt toForm: temp)		copy: aRect		from: otherLoc		in: nil		fillColor: (Bitmap with: 0)		rule: 32"Dumb example prints zero only when you move over the original	rectangle... | f diff | f := Form fromUser.	[Sensor anyButtonPressed] whileFalse:	[diff := f pixelCompare: f boundingBox	with: Display at: Sensor cursorPoint.	diff printString , ' ' displayAt: 0@0	"! !!Form methodsFor: 'analyzing' stamp: 'tpr 3/15/2013 12:27'!primCountBits	"Count the non-zero pixels of this form."	self depth > 8		ifTrue: [^ (self asFormOfDepth: 8) primCountBits].	^ (BitBlt toForm: self)		fillColor: (Bitmap with: 0);				destRect: (0 @ 0 extent: width @ height);		 combinationRule: 32;		 copyBits! !!Form methodsFor: 'analyzing' stamp: 'tpr 3/15/2013 18:49'!rectangleEnclosingPixelsNotOfColor: aColor 	"Answer the smallest rectangle enclosing all the pixels of me that are	different from the given color. Useful for extracting a foreground	graphic from its background."	"map the specified color to 1 and all others to 0"	| cm slice copyBlt countBlt top bottom newH left right |	cm := Bitmap				new: (1						bitShift: (self depth min: 15)).	cm primFill: 1.	cm		at: (aColor indexInMap: cm)		put: 0.	"build a 1-pixel high horizontal slice and BitBlts for counting pixels of	interest "	slice := Form extent: width @ 1 depth: 1.	copyBlt := (BitBlt toForm: slice) sourceForm: self;				 combinationRule: Form over;								destX: 0				destY: 0				width: width				height: 1;				 colorMap: cm.	countBlt := (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);								destRect: (0 @ 0 extent: slice extent);				 combinationRule: 32.	"scan in from top and bottom"	top := (0 to: height)				detect: [:y | 					copyBlt sourceOrigin: 0 @ y;						 copyBits.					countBlt copyBits > 0]				ifNone: [^ 0 @ 0 extent: 0 @ 0].	bottom := (height - 1 to: top by: -1)				detect: [:y | 					copyBlt sourceOrigin: 0 @ y;						 copyBits.					countBlt copyBits > 0].	"build a 1-pixel wide vertical slice and BitBlts for counting pixels of	interest "	newH := bottom - top + 1.	slice := Form extent: 1 @ newH depth: 1.	copyBlt := (BitBlt toForm: slice) sourceForm: self;				 combinationRule: Form over;								destX: 0				destY: 0				width: 1				height: newH;				 colorMap: cm.	countBlt := (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);								destRect: (0 @ 0 extent: slice extent);				 combinationRule: 32.	"scan in from left and right"	left := (0 to: width)				detect: [:x | 					copyBlt sourceOrigin: x @ top;						 copyBits.					countBlt copyBits > 0].	right := (width - 1 to: left by: -1)				detect: [:x | 					copyBlt sourceOrigin: x @ top;						 copyBits.					countBlt copyBits > 0].	^ left @ top corner: right + 1 @ (bottom + 1)! !!Form methodsFor: 'analyzing' stamp: 'jm 6/18/1999 18:41'!tallyPixelValues	"Answer a Bitmap whose elements contain the number of pixels in this	Form with the pixel value corresponding to their index. Note that the	pixels of multiple Forms can be tallied together using	tallyPixelValuesInRect:into:. "	^ self		tallyPixelValuesInRect: self boundingBox		into: (Bitmap				new: (1						bitShift: (self depth min: 15)))"	Move a little rectangle around the screen and print its tallies...	| r tallies nonZero |	Cursor blank showWhile: [	[Sensor anyButtonPressed] whileFalse:	[r := Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor:	nil. tallies := (Display copy: r) tallyPixelValues.	nonZero := (1 to: tallies size) select: [:i | (tallies at: i) > 0]	thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , ' ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor:	nil]] "! !!Form methodsFor: 'analyzing' stamp: 'tpr 3/15/2013 12:29'!tallyPixelValuesInRect: destRect into: valueTable 	"Tally the selected pixels of this Form into valueTable, a Bitmap of	depth 2^depth similar to a color map. Answer valueTable."	(BitBlt toForm: self) sourceForm: self;		 sourceOrigin: 0 @ 0;		 tallyMap: valueTable;		 combinationRule: 33;		 destRect: destRect;		 copyBits.	"src must be given for color map ops"	^ valueTable"	Move a little rectangle around the screen and print its tallies...	| r tallies nonZero |	Cursor blank showWhile: [	[Sensor anyButtonPressed] whileFalse:	[r := Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor:	nil. tallies := (Display copy: r) tallyPixelValues.	nonZero := (1 to: tallies size) select: [:i | (tallies at: i) > 0]	thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , ' ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor:	nil]] "! !!Form methodsFor: 'analyzing' stamp: 'tpr 3/15/2013 12:29'!xTallyPixelValue: pv orNot: not 	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm := self newColorMap.	"Map all colors but pv to zero"	not		ifTrue: [cm atAllPut: 1].	"... or all but pv to one"	cm at: pv + 1 put: 1			- (cm at: pv + 1).	slice := Form extent: 1 @ height.	copyBlt := (BitBlt				destForm: slice				sourceForm: self				halftoneForm: nil				combinationRule: Form over				destOrigin: 0 @ 0				sourceOrigin: 0 @ 0				extent: 1 @ slice height				clipRect: slice boundingBox)				colorMap: cm.	countBlt := (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);								destRect: (0 @ 0 extent: slice extent);				 combinationRule: 32.	^ (0 to: width - 1)		collect: [:x | 			copyBlt sourceOrigin: x @ 0;				 copyBits.			countBlt copyBits]! !!Form methodsFor: 'analyzing' stamp: 'tpr 3/15/2013 12:29'!yTallyPixelValue: pv orNot: not 	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm := self newColorMap.	"Map all colors but pv to zero"	not		ifTrue: [cm atAllPut: 1].	"... or all but pv to one"	cm at: pv + 1 put: 1			- (cm at: pv + 1).	slice := Form extent: width @ 1.	copyBlt := (BitBlt				destForm: slice				sourceForm: self				halftoneForm: nil				combinationRule: Form over				destOrigin: 0 @ 0				sourceOrigin: 0 @ 0				extent: slice width @ 1				clipRect: slice boundingBox)				colorMap: cm.	countBlt := (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);								destRect: (0 @ 0 extent: slice extent);				 combinationRule: 32.	^ (0 to: height - 1)		collect: [:y | 			copyBlt sourceOrigin: 0 @ y;				 copyBits.			countBlt copyBits]! !!Form methodsFor: 'bordering' stamp: 'tpr 3/15/2013 12:22'!borderFormOfWidth: borderWidth sharpCorners: sharpen 	"Smear this form around and then subtract the original to produce	an outline. If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	self depth > 1		ifTrue: [self halt].	"Only meaningful for B/W forms."	bigForm := self deepCopy.	all := bigForm boundingBox.	smearForm := Form extent: self extent.	smearPort := BitBlt toForm: smearForm.	sharpen		ifTrue: [cornerForm := Form extent: self extent.			cornerPort := BitBlt toForm: cornerForm].	nbrs := (0 @ 0) fourNeighbors.	1		to: borderWidth		do: [:i | 			"Iterate to get several layers of 'skin'"			nbrs				do: [:d | "Smear the self in 4 directions to grow each layer of					skin "					smearPort						copyForm: bigForm						to: d						rule: Form under].			sharpen				ifTrue: ["Special treatment to smear sharp corners"					nbrs						with: ((2 to: 5)								collect: [:i2 | nbrs atWrap: i2])						do: [:d1 :d2 | 							"Copy corner points diagonally"							cornerPort								copyForm: bigForm								to: d1 + d2								rule: Form over.							"But only preserve if there were dots on either							side "							cornerPort								copyForm: bigForm								to: d1 + d1 + d2								rule: Form and.							cornerPort								copyForm: bigForm								to: d1 + d2 + d2								rule: Form and.							smearPort								copyForm: cornerForm								to: 0 @ 0								rule: Form under]].			bigForm				copy: all				from: 0 @ 0				in: smearForm				rule: Form over].	"Now erase the original shape to obtain the outline"	bigForm		copy: all		from: 0 @ 0		in: self		rule: Form erase.	^ bigForm! !!Form methodsFor: 'bordering'!borderWidth: anInteger 	"Set the width of the border for the receiver to be anInteger and paint	it 	using black as the border color."	self		border: self boundingBox		width: anInteger		fillColor: Color black! !!Form methodsFor: 'bordering'!borderWidth: anInteger color: aMask 	"Set the width of the border for the receiver to be anInteger and paint	it 	using aMask as the border color."	self		border: self boundingBox		width: anInteger		fillColor: aMask! !!Form methodsFor: 'bordering'!borderWidth: anInteger fillColor: aMask 	"Set the width of the border for the receiver to be anInteger and paint	it 	using aMask as the border color."	self		border: self boundingBox		width: anInteger		fillColor: aMask! !!Form methodsFor: 'bordering' stamp: 'tpr 3/15/2013 12:22'!border: rect width: borderWidth rule: rule fillColor: fillColor 	"Paint a border whose rectangular area is defined by rect. The	width of the border of each side is borderWidth. Uses fillColor for	drawing the border."	| blt |	blt := (BitBlt toForm: self) combinationRule: rule;				 fillColor: fillColor.	blt sourceOrigin: 0 @ 0.	blt destOrigin: rect origin.	blt width: rect width;		 height: borderWidth;		 copyBits.	blt destY: rect corner y - borderWidth;		 copyBits.	blt destY: rect origin y + borderWidth.	blt height: rect height - borderWidth - borderWidth;		 width: borderWidth;		 copyBits.	blt destX: rect corner x - borderWidth;		 copyBits! !!Form methodsFor: 'bordering' stamp: 'di 10/21/2001 09:39'!shapeBorder: aColor width: borderWidth 	"A simplified version for shapes surrounded by transparency (as	SketchMorphs). Note also this returns a new form that may be larger,	and does not affect the original."	| shapeForm borderForm newForm |	newForm := Form extent: self extent + (borderWidth * 2) depth: self depth.	newForm fillColor: Color transparent.	self displayOn: newForm at: 0 @ 0 + borderWidth.	"First identify the shape in question as a B/W form"	shapeForm := (newForm makeBWForm: Color transparent) reverse.	"Now find the border of that shape"	borderForm := shapeForm borderFormOfWidth: borderWidth sharpCorners: false.	"Finally use that shape as a mask to paint the border with color"	^ newForm fillShape: borderForm fillColor: aColor! !!Form methodsFor: 'bordering'!shapeBorder: aColor width: borderWidth interiorPoint: interiorPoint sharpCorners: sharpen internal: internal 	"Identify the shape (region of identical color) at interiorPoint,	and then add an outline of width=borderWidth and color=aColor.	If sharpen is true, then cause right angles to be outlined by	right angles. If internal is true, then produce a border that lies	within the identified shape. Thus one can put an internal border	around the whole background, thus effecting a normal border	around every other foreground image."	"First identify the shape in question as a B/W form"	| shapeForm borderForm interiorColor |	interiorColor := self colorAt: interiorPoint.	shapeForm := (self makeBWForm: interiorColor) reverse				findShapeAroundSeedBlock: [:form | form pixelValueAt: interiorPoint put: 1].	"Reverse the image to grow the outline inward"	internal		ifTrue: [shapeForm reverse].	"Now find the border fo that shape"	borderForm := shapeForm borderFormOfWidth: borderWidth sharpCorners: sharpen.	"Finally use that shape as a mask to paint the border with color"	self fillShape: borderForm fillColor: aColor! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!balancedPatternFor: aColor 	"Return the pixel word for representing the given color on the receiver"	self hasNonStandardPalette		ifTrue: [^ self bitPatternFor: aColor]		ifFalse: [^ aColor balancedPatternForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!bitPatternFor: aColor 	"Return the pixel word for representing the given color on the receiver"	aColor isColor		ifFalse: [^ aColor bitPatternForDepth: self depth].	self hasNonStandardPalette		ifTrue: [^ Bitmap				with: (self pixelWordFor: aColor)]		ifFalse: [^ aColor bitPatternForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!colormapFromARGB	"Return a ColorMap mapping from canonical ARGB space into the	receiver. Note: This version is optimized for Squeak forms."	| map nBits |	self hasNonStandardPalette		ifTrue: [^ ColorMap mappingFromARGB: self rgbaBitMasks].	self depth <= 8		ifTrue: [map := Color colorMapIfNeededFrom: 32 to: self depth.			map size = 512				ifTrue: [nBits := 3].			map size = 4096				ifTrue: [nBits := 4].			map size = 32768				ifTrue: [nBits := 5].			^ ColorMap				shifts: (Array						with: 3 * nBits - 24						with: 2 * nBits - 16						with: 1 * nBits - 8						with: 0)				masks: (Array						with: 1 << nBits - 1 << (24 - nBits)						with: 1 << nBits - 1 << (16 - nBits)						with: 1 << nBits - 1 << (8 - nBits)						with: 0)				colors: map].	self depth = 16		ifTrue: [^ ColorMap shifts: #(-9 -6 -3 0 ) masks: #(16252928 63488 248 0 )].	self depth = 32		ifTrue: [^ ColorMap shifts: #(0 0 0 0 ) masks: #(16711680 65280 255 4278190080 )].	self error: 'Bad depth'! !!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:42'!colormapIfNeededForDepth: destDepth 	"Return a colormap for displaying the receiver at the given depth, or	nil if no colormap is needed."	self depth = destDepth		ifTrue: [^ nil].	"not needed if depths are the same"	^ Color colorMapIfNeededFrom: self depth to: destDepth! !!Form methodsFor: 'color mapping' stamp: 'ar 5/16/2001 22:23'!colormapIfNeededFor: destForm 	"Return a ColorMap mapping from the receiver to destForm."	(self hasNonStandardPalette			or: [destForm hasNonStandardPalette])		ifTrue: [^ self colormapFromARGB mappingTo: destForm colormapFromARGB]		ifFalse: [^ self colormapIfNeededForDepth: destForm depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!colormapToARGB	"Return a ColorMap mapping from the receiver into canonical ARGB	space. "	self hasNonStandardPalette		ifTrue: [^ self colormapFromARGB inverseMap].	self depth <= 8		ifTrue: [^ ColorMap				shifts: #(0 0 0 0 )				masks: #(16711680 65280 255 4278190080 )				colors: (Color colorMapIfNeededFrom: self depth to: 32)].	self depth = 16		ifTrue: [^ ColorMap shifts: #(9 6 3 0 ) masks: #(31744 992 31 0 )].	self depth = 32		ifTrue: [^ ColorMap shifts: #(0 0 0 0 ) masks: #(16711680 65280 255 4278190080 )].	self error: 'Bad depth'! !!Form methodsFor: 'color mapping'!makeBWForm: foregroundColor 	"Map this form into a B/W form with 1's in the foreground regions."	| bwForm map |	bwForm := Form extent: self extent.	map := self newColorMap.	"All non-foreground go to 0's"	map		at: (foregroundColor indexInMap: map)		put: 1.	bwForm		copyBits: self boundingBox		from: self		at: 0 @ 0		colorMap: map.	^ bwForm! !!Form methodsFor: 'color mapping' stamp: 'tpr 3/15/2013 12:26'!mapColors: oldColorBitsCollection to: newColorBits 	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color	accuracy on 32-bit Forms, since the transformation uses a color map	with only 15-bit resolution."	| map |	self depth < 16		ifTrue: [map := (Color cachedColormapFrom: self depth to: self depth) copy]		ifFalse: ["use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per			color component"			map := Color computeRGBColormapFor: self depth bitsPerColor: 5].	oldColorBitsCollection		do: [:oldColor | map at: oldColor put: newColorBits].	(BitBlt toForm: self) sourceForm: self;		 sourceOrigin: 0 @ 0;		 combinationRule: Form over;				destX: 0		destY: 0		width: width		height: height;		 colorMap: map;		 copyBits! !!Form methodsFor: 'color mapping' stamp: 'tpr 3/15/2013 12:26'!mapColor: oldColor to: newColor 	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color	accuracy on 32-bit Forms, since the transformation uses a color map	with only 15-bit resolution."	| map |	map := (Color cachedColormapFrom: self depth to: self depth) copy.	map		at: (oldColor indexInMap: map)		put: (newColor pixelWordForDepth: self depth).	(BitBlt toForm: self) sourceForm: self;		 sourceOrigin: 0 @ 0;		 combinationRule: Form over;				destX: 0		destY: 0		width: width		height: height;		 colorMap: map;		 copyBits! !!Form methodsFor: 'color mapping' stamp: 'ar 12/14/2001 18:11'!maskingMap	"Return a color map that maps all colors except transparent to words	of all ones. Used to create a mask for a Form whose transparent pixel	value is zero."	^ Color maskingMap: self depth! !!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:41'!newColorMap	"Return an uninitialized color map array appropriate to this Form's	depth. "	^ Bitmap		new: (1				bitShift: (self depth min: 15))! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!pixelValueFor: aColor 	"Return the pixel word for representing the given color on the receiver"	self hasNonStandardPalette		ifTrue: [^ self colormapFromARGB				mapPixel: (aColor pixelValueForDepth: 32)]		ifFalse: [^ aColor pixelValueForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!pixelWordFor: aColor 	"Return the pixel word for representing the given color on the receiver"	| basicPattern |	self hasNonStandardPalette		ifFalse: [^ aColor pixelWordForDepth: self depth].	basicPattern := self pixelValueFor: aColor.	self depth = 32		ifTrue: [^ basicPattern]		ifFalse: [^ aColor pixelWordFor: self depth filledWith: basicPattern]! !!Form methodsFor: 'color mapping' stamp: 'di 10/16/2001 15:23'!reducedPaletteOfSize: nColors 	"Return an array of colors of size nColors, such that those colors	represent well the pixel values actually found in this form."	| threshold tallies colorTallies dist delta palette cts top cluster |	tallies := self tallyPixelValues.	"An array of tallies for each pixel value"	threshold := width * height // 500.	"Make an array of (color -> tally) for all tallies over threshold"	colorTallies := Array				streamContents: [:s | tallies						withIndexDo: [:v :i | v >= threshold								ifTrue: [s nextPut: (Color colorFromPixelValue: i - 1 depth: depth)											-> v]]].	"Extract a set of clusters by picking the top tally, and then removing	all others	whose color is within dist of it. Iterate the process, adjusting dist until	we get nColors."	dist := 0.2.	delta := dist / 2.	[cts := colorTallies copy.	palette := Array				streamContents: [:s | [cts isEmpty]						whileFalse: [top := cts										detectMax: [:a | a value].							cluster := cts										select: [:a | (a key diff: top key)												< dist].							s nextPut: top key									-> (cluster											detectSum: [:a | a value]).							cts := cts copyWithoutAll: cluster]].	palette size = nColors		or: [delta < 0.001]]		whileFalse: [palette size > nColors				ifTrue: [dist := dist + delta]				ifFalse: [dist := dist - delta].			delta := delta / 2].	^ palette		collect: [:a | a key]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 20:14'!rgbaBitMasks	"Return the masks for specifying the R,G,B, and A components in the	receiver "	self depth <= 8		ifTrue: [^ #(16711680 65280 255 4278190080 )].	self depth = 16		ifTrue: [^ #(31744 992 31 0 )].	self depth = 32		ifTrue: [^ #(16711680 65280 255 4278190080 )].	self error: 'Bad depth for form'! !!Form methodsFor: 'converting' stamp: 'mt 5/10/2015 13:28'!adjustBrightness: brightness 	^ self		collectColors: [:color | color adjustSaturation: 0 brightness: brightness]! !!Form methodsFor: 'converting' stamp: 'mt 5/10/2015 13:26'!adjustSaturation: saturation 	^ self		collectColors: [:color | color adjustSaturation: saturation brightness: 0]! !!Form methodsFor: 'converting' stamp: 'jm 11/12/97 19:28'!as8BitColorForm	"Simple conversion of zero pixels to transparent. Force it to 8 bits."	| f map |	f := ColorForm extent: self extent depth: 8.	self displayOn: f at: self offset negated.	map := Color indexedColors copy.	map at: 1 put: Color transparent.	f colors: map.	f offset: self offset.	^ f! !!Form methodsFor: 'converting' stamp: 'RAA 8/14/2000 10:13'!asCursorForm	^ self as: StaticForm! !!Form methodsFor: 'converting' stamp: 'tpr 11/13/2015 15:38'!asFormOfDepth: d 	"Create a copy of me with depth 'd'. Includes a correction for some	bitmaps that when imported have poorly set up transparency"	| newForm |	d = self depth		ifTrue: [^ self].	newForm := Form extent: self extent depth: d.	(BitBlt toForm: newForm)		colorMap: (self colormapIfNeededFor: newForm);				copy: self boundingBox		from: 0 @ 0		in: self		fillColor: nil		rule: Form over.	"Special case: For a 16 -> 32 bit conversion fill the alpha channel	because it gets lost in translation."	d = 32		ifTrue: [newForm fixAlpha].	^ newForm! !!Form methodsFor: 'converting' stamp: 'lpc 5/19/2016 10:35'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale	ColorForm computed by extracting the brightness levels of one color	component. This technique allows a 32-bit Form to be converted to	an 8-bit ColorForm to save space while retaining a full 255 levels of	gray. (The usual colormapping technique quantizes to 8, 16, or 32	levels, which loses information.)"	| f32 srcForm result map bb |	self depth = 32		ifFalse: [f32 := Form extent: width @ height depth: 32.			self displayOn: f32.			^ f32 asGrayScale].	self unhibernate.	srcForm := Form extent: width * 4 @ height depth: 8.	srcForm bits: bits.	result := ColorForm extent: width @ height depth: 8.	map := Bitmap new: 256.	2		to: 256		do: [:i | map at: i put: i - 1].	map at: 1 put: 1.	"map zero pixel values to near-black"	bb := (BitBlt toForm: result) sourceForm: srcForm;				 combinationRule: Form over;				 colorMap: map.	0		to: width - 1		do: [:dstX | bb				sourceRect: (dstX * 4 + 2 @ 0 extent: 1 @ height);				 destOrigin: dstX @ 0;				 copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the	original "	map := Bitmap new: 512.	map at: 1 put: 255.	(BitBlt toForm: result) sourceForm: self;		 sourceRect: self boundingBox;		 destOrigin: 0 @ 0;		 combinationRule: Form erase;		 colorMap: map;		 copyBits.	result colors: ColorForm grayScalePalette.	^ result! !!Form methodsFor: 'converting' stamp: 'ar 2/7/2004 18:16'!asSourceForm	^ self! !!Form methodsFor: 'converting' stamp: 'ar 3/28/2010 15:34'!collectColors: aBlock 	"Create a new copy of the receiver with all the colors transformed by	aBlock "	^ self		collectPixels: [:pv | (aBlock				value: (Color colorFromPixelValue: pv depth: self depth))				pixelValueForDepth: self depth]! !!Form methodsFor: 'converting' stamp: 'ar 4/2/2010 22:35'!collectPixels: aBlock 	"Create a new copy of the receiver with all the pixels transformed by	aBlock "	self depth = 32		ifFalse: ["Perform the operation in 32bpp"			^ ((self asFormOfDepth: 32)				collectPixels: aBlock)				asFormOfDepth: self depth].	self unhibernate.	"ensure unhibernated before touching bits"	^ Form		extent: self extent		depth: self depth		bits: (self bits collect: aBlock)! !!Form methodsFor: 'converting' stamp: 'jm 4/5/1999 19:20'!colorReduced	"Return a color-reduced ColorForm version of the receiver, if possible,	or the receiver itself if not."	| tally tallyDepth colorCount newForm cm oldPixelValues newFormColors nextColorIndex c |	tally := self tallyPixelValues asArray.	tallyDepth := (tally size log: 2) asInteger.	colorCount := 0.	tally		do: [:n | n > 0				ifTrue: [colorCount := colorCount + 1]].	(tally at: 1)			= 0		ifTrue: [colorCount := colorCount + 1].	"include transparent"	colorCount > 256		ifTrue: [^ self].	"cannot reduce"	newForm := self formForColorCount: colorCount.	"build an array of just the colors used, and a color map to translate	old pixel values to their indices into this color array"	cm := Bitmap new: tally size.	oldPixelValues := self colormapIfNeededForDepth: 32.	newFormColors := Array new: colorCount.	newFormColors at: 1 put: Color transparent.	nextColorIndex := 2.	2		to: cm size		do: [:i | (tally at: i)					> 0				ifTrue: [oldPixelValues = nil						ifTrue: [c := Color colorFromPixelValue: i - 1 depth: tallyDepth]						ifFalse: [c := Color										colorFromPixelValue: (oldPixelValues at: i)										depth: 32].					newFormColors at: nextColorIndex put: c.					cm at: i put: nextColorIndex - 1.					"pixel values are zero-based indices"					nextColorIndex := nextColorIndex + 1]].	"copy pixels into new ColorForm, mapping to new pixel values"	newForm		copyBits: self boundingBox		from: self		at: 0 @ 0		clippingBox: self boundingBox		rule: Form over		fillColor: nil		map: cm.	newForm colors: newFormColors.	newForm offset: offset.	^ newForm! !!Form methodsFor: 'converting' stamp: 'nice 12/27/2009 05:16'!copyWithColorsReducedTo: nColors 	"Note: this has not been engineered.	There are better solutions in the literature."	| palette colorMap |	palette := self reducedPaletteOfSize: nColors.	colorMap := (1				to: (1 bitShift: depth))				collect: [:i | 					| pc closest |					pc := Color colorFromPixelValue: i - 1 depth: depth.					closest := palette								detectMin: [:c | c diff: pc].					closest pixelValueForDepth: depth].	^ self deepCopy		copyBits: self boundingBox		from: self		at: 0 @ 0		colorMap: (colorMap as: Bitmap)! !!Form methodsFor: 'converting' stamp: 'ar 3/28/2010 15:35'!darker	"Answer a darker variant of this form."	^ self		collectColors: [:color | color darker darker]! !!Form methodsFor: 'converting' stamp: 'ar 3/28/2010 15:35'!dimmed	"Answer a dimmed variant of this form."	^ self		collectColors: [:color | color				alpha: (color alpha min: 0.2)]! !!Form methodsFor: 'converting' stamp: 'ar 3/22/2010 22:38'!flipVertically	"Flip the image along the y axis"	| rowLen row topIndex botIndex |	self unhibernate.	rowLen := bits size // height.	row := Bitmap new: rowLen.	topIndex := 1.	botIndex := bits size - rowLen + 1.	1		to: height // 2		do: [:i | 			self				assert: [topIndex + rowLen <= botIndex].			row				replaceFrom: 1				to: rowLen				with: bits				startingAt: topIndex.			bits				replaceFrom: topIndex				to: topIndex + rowLen - 1				with: bits				startingAt: botIndex.			bits				replaceFrom: botIndex				to: botIndex + rowLen - 1				with: row				startingAt: 1.			topIndex := topIndex + rowLen.			botIndex := botIndex - rowLen]! !!Form methodsFor: 'converting' stamp: 'ar 3/28/2010 15:35'!lighter	"Answer a lighter variant of this form"	^ self		collectColors: [:color | color lighter lighter]! !!Form methodsFor: 'converting' stamp: 'ar 7/23/1999 17:04'!orderedDither32To16	"Do an ordered dithering for converting from 32 to 16 bit depth."	| ditherMatrix ii out inBits outBits index pv dmv r di dmi dmo g b pvOut outIndex |	self depth = 32		ifFalse: [^ self error: 'Must be 32bit for this'].	ditherMatrix := #(0 8 2 10 12 4 14 6 3 11 1 9 15 7 13 5 ).	ii := (0 to: 31)				collect: [:i | i].	out := Form extent: self extent depth: 16.	inBits := self bits.	outBits := out bits.	index := outIndex := 0.	pvOut := 0.	0		to: self height - 1		do: [:y | 			0				to: self width - 1				do: [:x | 					pv := inBits at: (index := index + 1).					dmv := ditherMatrix at: (y bitAnd: 3)									* 4									+ (x bitAnd: 3) + 1.					r := pv bitAnd: 255.					di := r * 496 bitShift: -8.					dmi := di bitAnd: 15.					dmo := di bitShift: -4.					r := dmv < dmi								ifTrue: [ii at: 2 + dmo]								ifFalse: [ii at: 1 + dmo].					g := (pv bitShift: -8)								bitAnd: 255.					di := g * 496 bitShift: -8.					dmi := di bitAnd: 15.					dmo := di bitShift: -4.					g := dmv < dmi								ifTrue: [ii at: 2 + dmo]								ifFalse: [ii at: 1 + dmo].					b := (pv bitShift: -16)								bitAnd: 255.					di := b * 496 bitShift: -8.					dmi := di bitAnd: 15.					dmo := di bitShift: -4.					b := dmv < dmi								ifTrue: [ii at: 2 + dmo]								ifFalse: [ii at: 1 + dmo].					pvOut := (pvOut bitShift: 16)								+ (b bitShift: 10)								+ (g bitShift: 5) + r.					(x bitAnd: 1)							= 1						ifTrue: [outBits at: (outIndex := outIndex + 1) put: pvOut.							pvOut := 0]].			(self width bitAnd: 1)					= 1				ifTrue: [outBits						at: (outIndex := outIndex + 1)						put: (pvOut bitShift: -16).					pvOut := 0]].	^ out! !!Form methodsFor: 'copying' stamp: 'cmm 1/19/2012 20:24'!blankCopyOf: aRectangle scaledBy: scale 	^ self species extent: (aRectangle extent * scale) truncated depth: depth! !!Form methodsFor: 'copying' stamp: 'cmm 1/19/2012 20:31'!contentsOfArea: aRect 	"Return a new form which derives from the portion of the original form	delineated by aRect."	^ self		contentsOfArea: aRect		into: (self species extent: aRect extent depth: depth)! !!Form methodsFor: 'copying' stamp: 'ar 6/9/2000 19:00'!contentsOfArea: aRect into: newForm 	"Return a new form which derives from the portion of the original form	delineated by aRect."	^ newForm		copyBits: aRect		from: self		at: 0 @ 0		clippingBox: newForm boundingBox		rule: Form over		fillColor: nil! !!Form methodsFor: 'copying' stamp: 'tpr 3/15/2013 12:22'!copyBits: sourceForm at: destOrigin translucent: factor 	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0 @ 0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor * 255.0) asInteger)				min: 255)	"	| f f2 f3 | f := Form fromUser. f2 := Form fromDisplay: (0@0 extent: f	extent). f3 := f2 deepCopy.	0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 := f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]	"! !!Form methodsFor: 'copying' stamp: 'tpr 3/15/2013 12:23'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm 	"Make up a BitBlt table and copy the bits."	(BitBlt		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) copyBits! !!Form methodsFor: 'copying' stamp: 'tpr 3/15/2013 12:23'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm map: map 	"Make up a BitBlt table and copy the bits. Use a colorMap."	((BitBlt		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect)		colorMap: map) copyBits! !!Form methodsFor: 'copying' stamp: 'tpr 3/15/2013 12:23'!copyBits: sourceRect from: sourceForm at: destOrigin colorMap: map 	"Make up a BitBlt table and copy the bits with the given colorMap."	((BitBlt		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: self boundingBox)		colorMap: map) copyBits! !!Form methodsFor: 'copying' stamp: 'cmm 1/19/2012 20:31'!copy: aRect 	"Return a new form which derives from the portion of the original form	delineated by aRect."	| newForm |	newForm := self species extent: aRect extent depth: depth.	^ newForm		copyBits: aRect		from: self		at: 0 @ 0		clippingBox: newForm boundingBox		rule: Form over		fillColor: nil! !!Form methodsFor: 'copying' stamp: 'tpr 3/15/2013 12:22'!copy: destRectangle from: sourcePt in: sourceForm rule: rule 	"Make up a BitBlt table and copy the bits."	(BitBlt toForm: self)		copy: destRectangle		from: sourcePt		in: sourceForm		fillColor: nil		rule: rule! !!Form methodsFor: 'copying'!copy: sourceRectangle from: sourceForm to: destPt rule: rule 	^ self		copy: (destPt extent: sourceRectangle extent)		from: sourceRectangle topLeft		in: sourceForm		rule: rule! !!Form methodsFor: 'copying' stamp: 'nice 12/13/2013 21:26'!deepCopy	^ self copy! !!Form methodsFor: 'copying' stamp: 'nice 12/13/2013 21:25'!postCopy	super postCopy.	bits := bits copy! !!Form methodsFor: 'copying' stamp: 'tk 8/19/1998 16:11'!veryDeepCopyWith: deepCopier 	"Return self. I am immutable in the Morphic world. Do not record me."	^ self! !!Form methodsFor: 'display box access'!boundingBox	^ Rectangle origin: 0 @ 0 corner: width @ height! !!Form methodsFor: 'display box access' stamp: 'tk 3/9/97'!center	"Note that offset is ignored here. Are we really going to embrace	offset? "	^ width @ height // 2! !!Form methodsFor: 'display box access'!computeBoundingBox	^ Rectangle origin: 0 @ 0 corner: width @ height! !!Form methodsFor: 'display box access'!height	^ height! !!Form methodsFor: 'display box access'!width	^ width! !!Form methodsFor: 'displaying' stamp: 'tpr 3/15/2013 12:40'!displayInterpolatedIn: aRectangle on: aForm 	"Display the receiver on aForm, using interpolation if necessary.	Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine adjustedR |	self extent = aRectangle extent		ifTrue: [^ self displayOn: aForm at: aRectangle origin].	engine := Smalltalk				at: #B3DRenderEngine				ifPresent: [:engineClass | engineClass defaultForPlatformOn: aForm].	engine		ifNil: ["We've got no bilinear interpolation. Use WarpBlt instead"			(WarpBlt toForm: aForm) sourceForm: self destRect: aRectangle;				 combinationRule: 3;				 cellSize: 2;				 warpBits.			^ self].	"Otherwise use the 3D engine for our purposes"	"there seems to be a slight bug in B3D which the following adjusts for"	adjustedR := (aRectangle withRight: aRectangle right + 1)				translateBy: 0 @ 1.	engine viewport: adjustedR.	engine		material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: self.	engine render: (Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect.	engine finish! !!Form methodsFor: 'displaying' stamp: 'tpr 3/15/2013 12:41'!displayInterpolatedOn: aForm 	"Display the receiver on aForm, using interpolation if necessary.	Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine |	self extent = aForm extent		ifTrue: [^ self displayOn: aForm].	engine := Smalltalk				at: #B3DRenderEngine				ifPresent: [:engineClass | engineClass defaultForPlatformOn: aForm].	engine		ifNil: ["We've got no bilinear interpolation. Use WarpBlt instead"			(WarpBlt toForm: aForm) sourceForm: self destRect: aForm boundingBox;				 combinationRule: 3;				 cellSize: 2;				 warpBits.			^ self].	"Otherwise use the 3D engine for our purposes"	engine viewport: aForm boundingBox.	engine		material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: self.	engine render: (Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect.	engine finish! !!Form methodsFor: 'displaying'!displayOnPort: port at: location 	port		copyForm: self		to: location		rule: Form over! !!Form methodsFor: 'displaying' stamp: 'ar 5/14/2001 23:33'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: rule fillColor: aForm 	aDisplayMedium		copyBits: self boundingBox		from: self		at: aDisplayPoint + self offset		clippingBox: clipRectangle		rule: rule		fillColor: aForm		map: (self colormapIfNeededFor: aDisplayMedium)! !!Form methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	"Graphically, it means nothing to scale a Form by floating point values.	Because scales and other display parameters are kept in floating	point to 	minimize round off errors, we are forced in this routine to round off to	the 	nearest integer."	| absolutePoint scale magnifiedForm |	absolutePoint := displayTransformation applyTo: relativePoint.	absolutePoint := absolutePoint x asInteger @ absolutePoint y asInteger.	displayTransformation noScale		ifTrue: [magnifiedForm := self]		ifFalse: [scale := displayTransformation scale.			scale := scale x @ scale y.			1 @ 1 = scale				ifTrue: [scale := nil.					magnifiedForm := self]				ifFalse: [magnifiedForm := self magnify: self boundingBox by: scale]].	magnifiedForm		displayOn: aDisplayMedium		at: absolutePoint - alignmentPoint		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!Form methodsFor: 'displaying' stamp: 'tpr 3/15/2013 12:41'!displayResourceFormOn: aForm 	"a special display method for blowing up resource thumbnails"	| engine tx cmap blitter |	self extent = aForm extent		ifTrue: [^ self displayOn: aForm].	engine := Smalltalk				at: #B3DRenderEngine				ifPresent: [:engineClass | engineClass defaultForPlatformOn: aForm].	engine		ifNil: ["We've got no bilinear interpolation. Use WarpBlt instead"			(WarpBlt toForm: aForm) sourceForm: self destRect: aForm boundingBox;				 combinationRule: 3;				 cellSize: 2;				 warpBits.			^ self].	tx := self asTexture.	(blitter := BitBlt toForm: tx) sourceForm: self;		 destRect: aForm boundingBox;		 sourceOrigin: 0 @ 0;		 combinationRule: Form paint.	"map transparency to current World background color"	(World color respondsTo: #pixelWordForDepth:)		ifTrue: [cmap := Bitmap						new: (self depth <= 8								ifTrue: [1 << self depth]								ifFalse: [4096]).			cmap				at: 1				put: (tx pixelWordFor: World color).			blitter colorMap: cmap].	blitter copyBits.	engine viewport: aForm boundingBox.	engine		material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: tx.	engine render: (Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect.	engine finish.	"the above, using bilinear interpolation doesn't leave transparent pixel	values intact"	(WarpBlt toForm: aForm) sourceForm: self destRect: aForm boundingBox;		 combinationRule: Form and;				colorMap: (Color maskingMap: self depth);		 warpBits! !!Form methodsFor: 'displaying' stamp: 'tpr 3/15/2013 12:41'!displayScaledOn: aForm 	"Display the receiver on aForm, scaling if necessary.	Form fromUser displayScaledOn: Display.	"	self extent = aForm extent		ifTrue: [^ self displayOn: aForm].	(WarpBlt toForm: aForm) sourceForm: self destRect: aForm boundingBox;		 combinationRule: Form paint;		 cellSize: 2;		 warpBits! !!Form methodsFor: 'displaying' stamp: 'tpr 3/15/2013 12:24'!drawLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Refer to the comment in 	DisplayMedium|drawLine:from:to:clippingBox:rule:mask:."	"set up an instance of BitBlt for display"	| dotSetter |	dotSetter := BitBlt				destForm: self				sourceForm: sourceForm				fillColor: aForm				combinationRule: anInteger				destOrigin: beginPoint				sourceOrigin: 0 @ 0				extent: sourceForm extent				clipRect: clipRect.	dotSetter drawFrom: beginPoint to: endPoint! !!Form methodsFor: 'displaying' stamp: 'tpr 3/15/2013 12:27'!paintBits: sourceForm at: destOrigin translucent: factor 	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0 @ 0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor * 255.0) asInteger)				min: 255)	"	| f f2 f3 | f := Form fromUser. f replaceColor: f peripheralColor	withColor: Color transparent.	f2 := Form fromDisplay: (0@0 extent: f extent). f3 := f2 deepCopy.	0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 := f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]	"! !!Form methodsFor: 'editing' stamp: 'dtl 1/23/2010 18:28'!bitEdit	"Create and schedule a view located in an area designated by the user 	that contains a view of the receiver magnified by 8@8 that can be 	modified using the Bit Editor. It also contains a view of the original 	form."	Project current bitEdit: self! !!Form methodsFor: 'editing' stamp: 'dtl 1/23/2010 18:36'!bitEditAt: magnifiedFormLocation scale: scaleFactor 	"Create and schedule a view whose top left corner is magnifiedLocation	and that contains a view of the receiver magnified by scaleFactor	that 	can be modified using the Bit Editor. It also contains a view of the 	original form."	Project current		bitEdit: self		at: magnifiedFormLocation		scale: scaleFactor! !!Form methodsFor: 'editing' stamp: 'dtl 2/10/2010 14:00'!edit	"Open a form editor on this form."	Project current formEdit: self! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 2/24/2001 22:41'!comeFullyUpOnReload: smartRefStream 	bits isForm		ifFalse: [^ self].	"make sure the resource gets loaded afterwards"	ResourceCollector current		ifNil: [^ self].	ResourceCollector current noteResource: bits replacing: self! !!Form methodsFor: 'fileIn/Out' stamp: 'di 8/5/1998 11:37'!hibernate	"Replace my bitmap with a compactly encoded representation (a	ByteArray). It is vital that BitBlt and any other access to the bitmap	(such as writing to a file) not be used when in this state. Since BitBlt	will fail if the bitmap size is wrong (not = bitsSize), we do not allow	replacement by a byteArray of the same (or larger) size."	"NOTE: This method copies code from Bitmap compressToByteArray so	that it can	nil out the old bits during the copy, thus avoiding 2x need for extra	storage. "	| compactBits lastByte |	(bits isMemberOf: Bitmap)		ifFalse: [^ self"already hibernated or weird state"].	compactBits := ByteArray new: bits size * 4 + 7 + (bits size // 1984 * 3).	lastByte := bits compress: bits toByteArray: compactBits.	lastByte < (bits size * 4)		ifTrue: [bits := nil.			"Let GC reclaim the old bits before the copy if necessary"			bits := compactBits copyFrom: 1 to: lastByte]! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 3/3/2001 16:16'!objectForDataStream: refStream 	| prj repl |	prj := refStream project.	prj		ifNil: [^ super objectForDataStream: refStream].	ResourceCollector current		ifNil: [^ super objectForDataStream: refStream].	repl := ResourceCollector current objectForDataStream: refStream fromForm: self.	^ repl! !!Form methodsFor: 'fileIn/Out' stamp: 'di 3/15/1999 14:50'!printOn: aStream 	aStream nextPutAll: self class name;		 nextPut: $(;		 print: width;		 nextPut: $x;		 print: height;		 nextPut: $x;		 print: depth;		 nextPut: $)! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:44'!readAttributesFrom: aBinaryStream 	| offsetX offsetY |	depth := aBinaryStream next.	(self depth isPowerOfTwo			and: [self depth between: 1 and: 32])		ifFalse: [self error: 'invalid depth; bad Form file?'].	width := aBinaryStream nextWord.	height := aBinaryStream nextWord.	offsetX := aBinaryStream nextWord.	offsetY := aBinaryStream nextWord.	offsetX > 32767		ifTrue: [offsetX := offsetX - 65536].	offsetY > 32767		ifTrue: [offsetY := offsetY - 65536].	offset := Point x: offsetX y: offsetY! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:43'!readBitsFrom: aBinaryStream 	bits := Bitmap newFromStream: aBinaryStream.	bits size = self bitsSize		ifFalse: [self error: 'wrong bitmap size; bad Form file?']! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 3/27/98 16:54'!readFromOldFormat: aBinaryStream 	"Read a Form in the original ST-80 format."	| w h offsetX offsetY newForm theBits pos |	self error: 'this method must be updated to read into 32-bit word bitmaps'.	w := aBinaryStream nextWord.	h := aBinaryStream nextWord.	offsetX := aBinaryStream nextWord.	offsetY := aBinaryStream nextWord.	offsetX > 32767		ifTrue: [offsetX := offsetX - 65536].	offsetY > 32767		ifTrue: [offsetY := offsetY - 65536].	newForm := Form extent: w @ h offset: offsetX @ offsetY.	theBits := newForm bits.	pos := 0.	1		to: w + 15 // 16		do: [:j | 1				to: h				do: [:i | theBits at: (pos := pos + 1) put: aBinaryStream nextWord]].	newForm bits: theBits.	^ newForm! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:44'!readFrom: aBinaryStream 	"Reads the receiver from the given binary stream with the format:	depth, extent, offset, bits."	self readAttributesFrom: aBinaryStream.	self readBitsFrom: aBinaryStream! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 2/24/2001 22:39'!replaceByResource: aForm 	"Replace the receiver by some resource that just got loaded"	(self extent = aForm extent			and: [self depth = aForm depth])		ifTrue: [bits := aForm bits]! !!Form methodsFor: 'fileIn/Out' stamp: 'nice 12/14/2013 14:47'!storeBitsOn: aStream base: anInteger 	self unhibernate.	bits		do: [:word | 			anInteger = 10				ifTrue: [aStream space]				ifFalse: [aStream crtab: 2].			word storeOn: aStream base: anInteger]! !!Form methodsFor: 'fileIn/Out'!storeOn: aStream 	self storeOn: aStream base: 10! !!Form methodsFor: 'fileIn/Out'!storeOn: aStream base: anInteger 	"Store the receiver out as an expression that can be evaluated to	recreate a Form with the same contents as the original."	self unhibernate.	aStream nextPut: $(.	aStream nextPutAll: self species name.	aStream crtab: 1.	aStream nextPutAll: 'extent: '.	self extent printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'depth: '.	self depth printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'fromArray: #('.	self storeBitsOn: aStream base: anInteger.	aStream nextPut: $).	aStream crtab: 1.	aStream nextPutAll: 'offset: '.	self offset printOn: aStream.	aStream nextPut: $)! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 3/3/2001 15:50'!unhibernate	"If my bitmap has been compressed into a ByteArray,	then expand it now, and return true."	| resBits |	bits isForm		ifTrue: [resBits := bits.			bits := Bitmap new: self bitsSize.			resBits displayResourceFormOn: self.			^ true].	bits == nil		ifTrue: [bits := Bitmap new: self bitsSize.			^ true].	(bits isMemberOf: ByteArray)		ifTrue: [bits := Bitmap decompressFromByteArray: bits.			^ true].	^ false! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:35'!writeAttributesOn: file 	self unhibernate.	file nextPut: depth.	file nextWordPut: width.	file nextWordPut: height.	file		nextWordPut: (self offset x >= 0				ifTrue: [self offset x]				ifFalse: [self offset x + 65536]).	file		nextWordPut: (self offset y >= 0				ifTrue: [self offset y]				ifFalse: [self offset y + 65536])! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:35'!writeBitsOn: file 	bits writeOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 6/16/2002 17:53'!writeBMPfileNamed: fName 	"Display writeBMPfileNamed: 'display.bmp'"	BMPReadWriter putForm: self onFileNamed: fName! !!Form methodsFor: 'fileIn/Out' stamp: 'sw 2/20/2002 15:37'!writeJPEGfileNamed: fileName 	"Write a JPEG file to the given filename using default settings"	self writeJPEGfileNamed: fileName progressive: false	"	Display writeJPEGfileNamed: 'display.jpeg'	Form fromUser writeJPEGfileNamed: 'yourPatch.jpeg	"! !!Form methodsFor: 'fileIn/Out' stamp: 'sw 2/20/2002 15:29'!writeJPEGfileNamed: fileName progressive: aBoolean 	"Write a JPEG file to the given filename using default settings. Make it	progressive or not, depending on the boolean argument"	JPEGReadWriter2		putForm: self		quality: -1		progressiveJPEG: aBoolean		onFileNamed: fileName	"default"	"	Display writeJPEGfileNamed: 'display.jpeg' progressive: false.	Form fromUser writeJPEGfileNamed: 'yourPatch.jpeg' progressive: tru	"! !!Form methodsFor: 'fileIn/Out' stamp: 'di 7/6/1998 23:00'!writeOnMovie: file 	"Write just my bits on the file."	self unhibernate.	bits writeUncompressedOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:36'!writeOn: file 	"Write the receiver on the file in the format	depth, extent, offset, bits."	self writeAttributesOn: file.	self writeBitsOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'cbc 3/13/2013 16:10'!writePNGfileNamed: fName 	"Display writePNGfileNamed: 'display.png'"	PNGReadWriter putForm: self onFileNamed: fName! !!Form methodsFor: 'fileIn/Out' stamp: 'tk 2/19/1999 07:30'!writeUncompressedOn: file 	"Write the receiver on the file in the format depth, extent, offset, bits.	Warning: Caller must put header info on file!! Use	writeUncompressedOnFileNamed: instead."	self unhibernate.	file binary.	file nextPut: depth.	file nextWordPut: width.	file nextWordPut: height.	file		nextWordPut: (self offset x >= 0				ifTrue: [self offset x]				ifFalse: [self offset x + 65536]).	file		nextWordPut: (self offset y >= 0				ifTrue: [self offset y]				ifFalse: [self offset y + 65536]).	bits writeUncompressedOn: file! !!Form methodsFor: 'filling' stamp: 'di 2/19/1999 07:07'!anyShapeFill	"Fill the interior of the outermost outlined region in the receiver, a 1-bit	deep form. Typically the resulting form is used with fillShape:fillColor:	to paint a solid color. See also convexShapeFill:"	"Draw a seed line around the edge and fill inward from the outside."	| shape |	shape := self				findShapeAroundSeedBlock: [:f | f borderWidth: 1].	"Reverse so that this becomes solid in the middle"	shape := shape reverse.	"Finally erase any bits from the original so the fill is only elsewhere"	shape		copy: shape boundingBox		from: self		to: 0 @ 0		rule: Form erase.	^ shape! !!Form methodsFor: 'filling'!bitPatternForDepth: suspectedDepth 	"Only called when a Form is being used as a fillColor. Use a Pattern or	InfiniteForm instead for this purpose.	Interpret me as an array of (32/depth) Color pixelValues. BitBlt aligns	the first element of this array with the top scanline of the	destinationForm, the second with the second, and so on, cycling	through the color array as necessary. 6/18/96 tk"	^ self! !!Form methodsFor: 'filling' stamp: 'di 9/11/1998 16:25'!convexShapeFill: aMask 	"Fill the interior of the outtermost outlined region in the receiver. The	outlined region must not be concave by more than 90 degrees.	Typically aMask is Color black, to produce a solid fill. then the resulting	form is used with fillShape: to paint a solid color. See also anyShapeFill"	| destForm tempForm |	destForm := Form extent: self extent.	destForm fillBlack.	tempForm := Form extent: self extent.	(0 @ 0) fourNeighbors		do: [:dir | 			"Smear self in all 4 directions, and AND the result"			self displayOn: tempForm at: 0 @ 0 - self offset.			tempForm smear: dir distance: (dir dotProduct: tempForm extent) abs.			tempForm				displayOn: destForm				at: 0 @ 0				clippingBox: destForm boundingBox				rule: Form and				fillColor: nil].	destForm		displayOn: self		at: 0 @ 0		clippingBox: self boundingBox		rule: Form over		fillColor: aMask! !!Form methodsFor: 'filling' stamp: 'tpr 3/15/2013 12:24'!eraseShape: bwForm 	"use bwForm as a mask to clear all pixels where bwForm has 1's"	((BitBlt		destForm: self		sourceForm: bwForm		fillColor: nil		combinationRule: Form erase1bitShape		destOrigin: bwForm offset		sourceOrigin: 0 @ 0		extent: self extent		clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 4294967295)) copyBits! !!Form methodsFor: 'filling'!fillFromXColorBlock: colorBlock 	"Horizontal Gradient Fill.	Supply relative x in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| xRel |	0		to: width - 1		do: [:x | 			xRel := x asFloat / (width - 1) asFloat.			self				fill: (x @ 0 extent: 1 @ height)				fillColor: (colorBlock value: xRel)			"			((Form extent: 100@100 depth: Display depth)			fillFromXColorBlock: [:x | Color r: x g: 0.0 b: 0.5]) displa			"]! !!Form methodsFor: 'filling' stamp: 'tpr 3/15/2013 12:25'!fillFromXYColorBlock: colorBlock 	"General Gradient Fill.	Supply relative x and y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| poker yRel xRel |	poker := BitBlt bitPokerToForm: self.	0		to: height - 1		do: [:y | 			yRel := y asFloat / (height - 1) asFloat.			0				to: width - 1				do: [:x | 					xRel := x asFloat / (width - 1) asFloat.					poker						pixelAt: x @ y						put: ((colorBlock value: xRel value: yRel)								pixelWordForDepth: self depth)]			"			| d |			((Form extent: 100@20 depth: Display depth)			fillFromXYColorBlock:			[:x :y | d := 1.0 - (x - 0.5) abs - (y - 0.5) abs.			Color r: d g: 0 b: 1.0-d]) displa			"]! !!Form methodsFor: 'filling'!fillFromYColorBlock: colorBlock 	"Vertical Gradient Fill.	Supply relative y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| yRel |	0		to: height - 1		do: [:y | 			yRel := y asFloat / (height - 1) asFloat.			self				fill: (0 @ y extent: width @ 1)				fillColor: (colorBlock value: yRel)			"			((Form extent: 100@100 depth: Display depth)			fillFromYColorBlock: [:y | Color r: y g: 0.0 b: 0.5]) displa			"]! !!Form methodsFor: 'filling' stamp: 'tpr 3/15/2013 12:25'!fill: aRectangle rule: anInteger fillColor: aForm 	"Replace a rectangular area of the receiver with the pattern described	by aForm 	according to the rule anInteger."	(BitBlt toForm: self)		copy: aRectangle		from: 0 @ 0		in: nil		fillColor: aForm		rule: anInteger! !!Form methodsFor: 'filling' stamp: 'tpr 3/15/2013 12:25'!findShapeAroundSeedBlock: seedBlock 	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'. Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	self depth > 1		ifTrue: [self halt].	"Only meaningful for B/W forms."	all := self boundingBox.	smearForm := Form extent: self extent.	smearPort := BitBlt toForm: smearForm.	seedBlock value: smearForm.	"Blacken seeds to be smeared"	smearPort		copyForm: self		to: 0 @ 0		rule: Form erase.	"Clear any in black"	previousSmear := smearForm deepCopy.	count := 1.	[count = 10		and: ["check for no change every 10 smears"			count := 1.			previousSmear				copy: all				from: 0 @ 0				in: smearForm				rule: Form reverse.			previousSmear isAllWhite]]		whileFalse: [smearPort				copyForm: smearForm				to: 1 @ 0				rule: Form under.			smearPort				copyForm: smearForm				to: -1 @ 0				rule: Form under.			"After horiz smear, trim around the region border"			smearPort				copyForm: self				to: 0 @ 0				rule: Form erase.			smearPort				copyForm: smearForm				to: 0 @ 1				rule: Form under.			smearPort				copyForm: smearForm				to: 0 @ -1				rule: Form under.			"After vert smear, trim around the region border"			smearPort				copyForm: self				to: 0 @ 0				rule: Form erase.			count := count + 1.			count = 9				ifTrue: ["Save penultimate smear for comparison"					previousSmear						copy: all						from: 0 @ 0						in: smearForm						rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!Form methodsFor: 'filling' stamp: 'tpr 3/26/2013 11:11'!floodFill2: aColor at: interiorPoint 	"Fill the shape (4-connected) at interiorPoint. The algorithm is based	on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic	Press, 1990.	NOTE: This is a less optimized variant for flood filling which is precisely	along the lines of Heckbert's algorithm. For almost all cases	#floodFill:at: will be faster (see the comment there) but this method is	left in both as reference and as a fallback if such a strange case is	encountered in reality."	| poker stack old new x y top x1 x2 dy left goRight |	poker := BitBlt bitPokerToForm: self.	stack := OrderedCollection new: 50.	"read old pixel value"	old := self pixelValueAt: interiorPoint.	"compute new value"	new := self pixelValueFor: aColor.	old = new		ifTrue: [^ self].	"no point, is there?!!"	x := interiorPoint x.	y := interiorPoint y.	(y >= 0			and: [y < height])		ifTrue: [stack addLast: {y. x. x. 1}.			"y, left, right, dy"			stack addLast: {y + 1. x. x. -1}].	[stack isEmpty]		whileFalse: [top := stack removeLast.			y := top at: 1.			x1 := top at: 2.			x2 := top at: 3.			dy := top at: 4.			y := y + dy.			"Segment of scanline (y-dy) for x1 <= x <= x2 was previously			filled. Now explore adjacent pixels in scanline y."			x := x1.			[x >= 0				and: [(self pixelValueAt: x @ y)						= old]]				whileTrue: [poker pixelAt: x @ y put: new.					x := x - 1].			goRight := x < x1.			left := x + 1.			(left < x1					and: [y - dy >= 0							and: [y - dy < height]])				ifTrue: [stack addLast: {y. left. x1 - 1. 0 - dy}].			goRight				ifTrue: [x := x1 + 1].			[goRight				ifTrue: [[x < width						and: [(self pixelValueAt: x @ y)								= old]]						whileTrue: [poker pixelAt: x @ y put: new.							x := x + 1].					(y + dy >= 0							and: [y + dy < height])						ifTrue: [stack addLast: {y. left. x - 1. dy}].					(x > (x2 + 1)							and: [y - dy >= 0									and: [y - dy >= 0]])						ifTrue: [stack addLast: {y. x2 + 1. x - 1. 0 - dy}]].			[(x := x + 1) <= x2				and: [(self pixelValueAt: x @ y)						~= old]] whileTrue.			left := x.			goRight := true.			x <= x2] whileTrue]! !!Form methodsFor: 'filling' stamp: 'di 10/20/2001 10:09'!floodFillMapFrom: sourceForm to: scanlineForm mappingColorsWithin: dist to: centerPixVal 	"This is a helper routine for floodFill. It's written for clarity (scanning	the entire	map using colors) rather than speed (which would require hacking	rgb components	in the nieghborhood of centerPixVal. Note that some day a better	proximity metric	would be (h s v) where tolerance could be reduced in hue."	| colorMap centerColor |	scanlineForm depth = 32		ifFalse: [self error: 'depth 32 assumed'].	"First get a modifiable identity map"	colorMap := (Color cachedColormapFrom: sourceForm depth to: scanlineForm depth) copy.	centerColor := Color				colorFromPixelValue: (centerPixVal bitOr: 65510)				depth: scanlineForm depth.	"Now replace all entries that are close to the centerColor"	1		to: colorMap size		do: [:i | ((Color					colorFromPixelValue: ((colorMap at: i)							bitOr: 65510)					depth: scanlineForm depth)					diff: centerColor)					<= dist				ifTrue: [colorMap at: i put: centerPixVal]].	^ colorMap! !!Form methodsFor: 'filling' stamp: 'di 10/20/2001 22:03'!floodFill: aColor at: interiorPoint 	Preferences areaFillsAreVeryTolerant		ifTrue: [^ self				floodFill: aColor				at: interiorPoint				tolerance: 0.2].	Preferences areaFillsAreTolerant		ifTrue: [^ self				floodFill: aColor				at: interiorPoint				tolerance: 0.1].	^ self		floodFill: aColor		at: interiorPoint		tolerance: 0! !!Form methodsFor: 'filling' stamp: 'tpr 3/15/2013 12:26'!floodFill: aColor at: interiorPoint tolerance: tolerance 	"Fill the shape (4-connected) at interiorPoint. The algorithm is based	on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic	Press, 1990.	NOTE (ar): This variant has been heavily optimized to prevent the	overhead of repeated calls to BitBlt. Usually this is a really big winner	but the runtime now depends a bit on the complexity of the shape to	be filled. For extremely complex shapes (say, a Hilbert curve) with	very few pixels to fill it can be slower than #floodFill2:at: since it	needs to repeatedly read the source bits. However, in all practical	cases I found this variant to be 15-20 times faster than anything else.	Further note (di): I have added a feature that allows this routine to fill	areas of approximately constant color (such as photos, scans, and	jpegs). It does this by computing a color map for the peeker that	maps all colors close to 'old' into colors identical to old. This mild	colorblindness achieves the desired effect with no further change or	degradation of the algorithm. tolerance should be 0 (exact match), or	a value corresponding to those returned by Color>>diff:, with 0.1	being a reasonable starting choice."	| peeker poker stack old new x y top x1 x2 dy left goRight span spanBits w box debug |	debug := false.	"set it to true to see the filling process"	box := interiorPoint extent: 1 @ 1.	span := Form extent: width @ 1 depth: 32.	spanBits := span bits.	peeker := BitBlt toForm: span.	peeker sourceForm: self;		 combinationRule: 3;		 width: width;		 height: 1.	"read old pixel value"	peeker sourceOrigin: interiorPoint;		 destOrigin: interiorPoint x @ 0;		 width: 1;		 copyBits.	old := spanBits at: interiorPoint x + 1.	"compute new value (take care since the algorithm will fail if old =	new) "	new := self privateFloodFillValue: aColor.	old = new		ifTrue: [^ box].	tolerance > 0		ifTrue: ["Set up color map for approximate fills"			peeker				colorMap: (self						floodFillMapFrom: self						to: span						mappingColorsWithin: tolerance						to: old)].	poker := BitBlt toForm: self.	poker fillColor: aColor;		 combinationRule: 3;		 width: width;		 height: 1.	stack := OrderedCollection new: 50.	x := interiorPoint x.	y := interiorPoint y.	(y >= 0			and: [y < height])		ifTrue: [stack addLast: {y. x. x. 1}.			"y, left, right, dy"			stack addLast: {y + 1. x. x. -1}].	[stack isEmpty]		whileFalse: [debug				ifTrue: [self displayOn: Display].			top := stack removeLast.			y := top at: 1.			x1 := top at: 2.			x2 := top at: 3.			dy := top at: 4.			y := y + dy.			debug				ifTrue: [Display						drawLine: (Form extent: 1 @ 1 depth: 8) fillWhite						from: x1 - 1 @ y						to: x2 + 1 @ y						clippingBox: Display boundingBox						rule: Form over						fillColor: nil].			"Segment of scanline (y-dy) for x1 <= x <= x2 was previously			filled. Now explore adjacent pixels in scanline y."			peeker sourceOrigin: 0 @ y;				 destOrigin: 0 @ 0;				 width: width;				 copyBits.			"Note: above is necessary since we don't know where we'll end			up filling"			x := x1.			w := 0.			[x >= 0				and: [(spanBits at: x + 1)						= old]]				whileTrue: [w := w + 1.					x := x - 1].			w > 0				ifTrue: ["overwrite pixels"					poker destOrigin: x + 1 @ y;						 width: w;						 copyBits.					box := box								quickMerge: (x + 1 @ y extent: w @ 1)].			goRight := x < x1.			left := x + 1.			(left < x1					and: [y - dy >= 0							and: [y - dy < height]])				ifTrue: [stack addLast: {y. left. x1 - 1. 0 - dy}].			goRight				ifTrue: [x := x1 + 1].			[goRight				ifTrue: [w := 0.					[x < width						and: [(spanBits at: x + 1)								= old]]						whileTrue: [w := w + 1.							x := x + 1].					w > 0						ifTrue: ["overwrite pixels"							poker destOrigin: x - w @ y;								 width: w;								 copyBits.							box := box										quickMerge: (x - w @ y extent: w @ 1)].					(y + dy >= 0							and: [y + dy < height])						ifTrue: [stack addLast: {y. left. x - 1. dy}].					(x > (x2 + 1)							and: [y - dy >= 0									and: [y - dy >= 0]])						ifTrue: [stack addLast: {y. x2 + 1. x - 1. 0 - dy}]].			[(x := x + 1) <= x2				and: [(spanBits at: x + 1)						~= old]] whileTrue.			left := x.			goRight := true.			x <= x2] whileTrue].	^ box! !!Form methodsFor: 'filling' stamp: 'di 10/17/2001 10:10'!shapeFill: aColor interiorPoint: interiorPoint 	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for	potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	self depth = 1		ifTrue: [^ self				shapeFill: aColor				seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	"bwForm := self makeBWForm: interiorColor."	"won't work for two whites"	interiorPixVal := self pixelValueAt: interiorPoint.	bwForm := Form extent: self extent.	map := Bitmap				new: (1						bitShift: (self depth min: 12)).	"Not calling newColorMap. All 	non-foreground go to 0. Length is 2 to 4096."	ppd := self depth.	"256 long color map in depth 8 is not one of the following cases"	3		to: 5		do: [:bitsPerColor | (2 raisedTo: bitsPerColor * 3)					= map size				ifTrue: [ppd := bitsPerColor * 3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal + 1 put: 1]		ifFalse: [interiorPixVal = 0				ifTrue: [map at: 1 put: 1]				ifFalse: [color := Color colorFromPixelValue: interiorPixVal depth: self depth.					ind := color pixelValueForDepth: ppd.					map at: ind + 1 put: 1]].	bwForm		copyBits: self boundingBox		from: self		at: 0 @ 0		colorMap: map.	bwForm reverse.	"Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm := bwForm				findShapeAroundSeedBlock: [:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	self eraseShape: bwForm.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:38'!shapeFill: aColor seedBlock: seedBlock 	self depth > 1		ifTrue: [self error: 'This call only meaningful for B/W forms'].	(self findShapeAroundSeedBlock: seedBlock)		displayOn: self		at: 0 @ 0		clippingBox: self boundingBox		rule: Form under		fillColor: aColor! !!Form methodsFor: 'image manipulation' stamp: 'tpr 3/15/2013 12:29'!replaceColor: oldColor withColor: newColor 	"Replace one color with another everywhere is this form"	| cm newInd target ff |	self depth = 32		ifTrue: [cm := (Color cachedColormapFrom: 16 to: 32) copy]		ifFalse: [cm := Bitmap						new: (1								bitShift: (self depth min: 15)).			1				to: cm size				do: [:i | cm at: i put: i - 1]].	newInd := newColor pixelValueForDepth: self depth.	cm at: (oldColor			pixelValueForDepth: (self depth min: 16))			+ 1 put: newInd.	target := newColor isTransparent				ifTrue: [ff := Form extent: self extent depth: depth.					ff fillWithColor: newColor.					ff]				ifFalse: [self].	(BitBlt toForm: target) sourceForm: self;		 sourceOrigin: 0 @ 0;		 combinationRule: Form paint;				destX: 0		destY: 0		width: width		height: height;		 colorMap: cm;		 copyBits.	newColor = Color transparent		ifTrue: [target displayOn: self]! !!Form methodsFor: 'image manipulation' stamp: 'tpr 3/15/2013 12:29'!smear: dir distance: dist 	"Smear any black pixels in this form in the direction dir in Log N steps"	| skew bb |	bb := BitBlt				destForm: self				sourceForm: self				fillColor: nil				combinationRule: Form under				destOrigin: 0 @ 0				sourceOrigin: 0 @ 0				extent: self extent				clipRect: self boundingBox.	skew := 1.	[skew < dist]		whileTrue: [bb destOrigin: dir * skew;				 copyBits.			skew := skew + skew]! !!Form methodsFor: 'image manipulation' stamp: 'jm 6/30/1999 15:36'!trimBordersOfColor: aColor 	"Answer a copy of this Form with each edge trimmed in to the first	pixel that is not of the given color. (That is, border strips of the given	color are removed)."	| r |	r := self rectangleEnclosingPixelsNotOfColor: aColor.	^ self copy: r! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/17/2001 22:54'!allocateForm: extentPoint 	"Allocate a new form which is similar to the receiver and can be used	for accelerated blts"	^ Form extent: extentPoint depth: self nativeDepth! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:46'!finish	"If there are any pending operations on the receiver complete them.	Do not return before all modifications have taken effect."	^ self! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:45'!flush	"If there are any pending operations on the receiver start doing them.	In time, they will show up on the receiver but not necessarily	immediately after this method returns."	^ self! !!Form methodsFor: 'initialize-release'!fromDisplay: aRectangle 	"Create a virtual bit map from a user specified rectangular area on the 	display screen. Reallocates bitmap only if aRectangle ~= the	receiver's 	extent."	(width = aRectangle width			and: [height = aRectangle height])		ifFalse: [self setExtent: aRectangle extent depth: depth].	self		copyBits: (aRectangle origin extent: self extent)		from: Display		at: 0 @ 0		clippingBox: self boundingBox		rule: Form over		fillColor: nil! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/28/2000 18:45'!shutDown	"The system is going down. Try to preserve some space"	self hibernate! !!Form methodsFor: 'initialize-release' stamp: 'ar 6/16/2002 18:39'!swapEndianness	"Swap from big to little endian pixels and vice versa"	depth := 0 - depth! !!Form methodsFor: 'other' stamp: 'ar 4/30/2008 12:18'!fillAlpha: alphaValue 	"Fill a 32bit form with a constant alpha value"	| bb |	self depth = 32		ifFalse: [^ self error: 'Only valid for 32 bit forms'].	bb := BitBlt toForm: self.	bb combinationRule: 7.	bb		fillColor: (Bitmap with: alphaValue << 24).	bb copyBits! !!Form methodsFor: 'other' stamp: 'ar 12/12/2003 18:24'!fixAlpha	"Fix the alpha channel if the receiver is 32bit"	| bb |	self depth = 32		ifFalse: [^ self].	bb := BitBlt toForm: self.	bb combinationRule: 40.	"fixAlpha:with:"	bb copyBits! !!Form methodsFor: 'other' stamp: 'jm 9/27/97 21:02'!formForColorCount: colorCount 	"Return a ColorForm of sufficient depth to represent the given number	of colors. The maximum number of colors is 256."	colorCount > 256		ifTrue: [^ self error: 'too many colors'].	colorCount > 16		ifTrue: [^ ColorForm extent: self extent depth: 8].	colorCount > 4		ifTrue: [^ ColorForm extent: self extent depth: 4].	colorCount > 2		ifTrue: [^ ColorForm extent: self extent depth: 2].	^ ColorForm extent: self extent depth: 1! !!Form methodsFor: 'other' stamp: 'bf 8/17/2009 13:08'!preMultiplyAlpha	"Pre-multiply each pixel by its alpha, for proper alpha compositing	(BitBlt rule 34).	E.g., half-transparent green 16r7F00FF00 becomes 16r7F007F00"	depth = 32		ifFalse: [^ self].	1		to: bits size		do: [:i | 			| v a r g b |			v := bits at: i.			a := v bitShift: -24.			r := ((v bitShift: -16)						bitAnd: 255)						* a // 255.			g := ((v bitShift: -8)						bitAnd: 255)						* a // 255.			b := (v bitAnd: 255)						* a // 255.			bits at: i put: (a bitShift: 24)					+ (r bitShift: 16)					+ (g bitShift: 8) + b]! !!Form methodsFor: 'other' stamp: 'jm 1/6/98 10:37'!primPrintHScale: hScale vScale: vScale landscape: aBoolean 	"On platforms that support it, this primitive prints the receiver,	assumed to be a Form, to the default printer."	"(Form extent: 10@10) primPrintHScale: 1.0 vScale: 1.0 landscape:	true "	self halt.	self primitiveFailed! !!Form methodsFor: 'other' stamp: 'RAA 1/30/2002 16:42'!relativeTextAnchorPosition	^ nil"so forms can be in TextAnchors"! !!Form methodsFor: 'other' stamp: 'dtl 2/27/2010 09:59'!setAsBackground	"Set this form as a background image."	Project current setAsBackground: self! !!Form methodsFor: 'pixel access' stamp: 'ar 5/17/2001 15:42'!colorAt: aPoint 	"Return the color in the pixel at the given point. "	^ Color		colorFromPixelValue: (self pixelValueAt: aPoint)		depth: self depth! !!Form methodsFor: 'pixel access' stamp: 'ar 5/14/2001 23:46'!colorAt: aPoint put: aColor 	"Store a Color into the pixel at coordinate aPoint. "	self		pixelValueAt: aPoint		put: (self pixelValueFor: aColor)! !!Form methodsFor: 'pixel access' stamp: 'ar 5/17/2001 15:39'!isTransparentAt: aPoint 	"Return true if the receiver is transparent at the given point."	self depth = 1		ifTrue: [^ false].	"no transparency at depth 1"	^ (self pixelValueAt: aPoint)		= (self pixelValueFor: Color transparent)! !!Form methodsFor: 'pixel access' stamp: 'tpr 3/14/2013 17:36'!pixelValueAt: aPoint 	"Return the raw pixel value at the given point. This pixel value	depends on the receiver's depth. Typical clients use colorAt: to get a	Color. "	^ self primPixelValueAtX: aPoint x y: aPoint y! !!Form methodsFor: 'pixel access' stamp: 'tpr 3/15/2013 12:27'!pixelValueAt: aPoint put: pixelValue 	"Store the given raw pixel value at the given point. Typical clients use	colorAt:put: to store a color."	(BitBlt bitPokerToForm: self)		pixelAt: aPoint		put: pixelValue! !!Form methodsFor: 'pixel access' stamp: 'tpr 3/26/2013 11:10'!primPixelValueAtX: x y: y 	"Return the raw pixel value at the given point. This pixel value	depends on the receiver's depth. Typical clients use colorAt: to get a	Color. Make sure the colorMap is nil for ColorForms"	self halt.	^ (BitBlt bitPeekerFromForm: self) colorMap: nil;		 pixelAt: x @ y! !!Form methodsFor: 'postscript generation' stamp: 'ar 5/17/2001 15:36'!bitsPerComponent	^ self depth <= 8		ifTrue: [self depth]		ifFalse: [8]! !!Form methodsFor: 'postscript generation' stamp: 'mpw 11/14/1999 22:22'!bytesPerRow	^ self numComponents * self paddedWidth * self bitsPerComponent / 8! !!Form methodsFor: 'postscript generation' stamp: 'ar 5/17/2001 15:39'!decodeArray	^ self depth <= 8		ifTrue: ['[1 0]']		ifFalse: ['[0 1 0 1 0 1 ]']! !!Form methodsFor: 'postscript generation' stamp: 'ar 5/17/2001 15:43'!numComponents	^ self depth <= 8		ifTrue: [1]		ifFalse: [3]! !!Form methodsFor: 'postscript generation'!paddedWidth	^ self width + (self rowPadding - 1) // self rowPadding * self rowPadding! !!Form methodsFor: 'postscript generation' stamp: 'nk 12/31/2003 15:46'!printPostscript: aStream operator: operator 	aStream		preserveStateDuring: [:inner | 			inner				rectclip: (0 @ 0 extent: width @ height).			self setColorspaceOn: inner.			inner print: '[ ';				 cr;				 print: '/ImageType 1';				 cr;				 print: '/ImageMatrix [1 0 0 1 0 0]';				 cr;				 print: '/MultipleDataSources false';				 cr;				 print: '/DataSource level1 { { currentfile ';				 write: self bytesPerRow;				 print: ' string readhexstring pop }} bind { currentfile /ASCIIHexDecode filter } ifelse';				 cr;				 print: '/Width ';				 write: self paddedWidth;				 cr;				 print: '/Height ';				 write: self height;				 cr;				 print: '/Decode ';				 print: self decodeArray;				 cr;				 print: '/BitsPerComponent ';				 write: self bitsPerComponent;				 cr;				 print: 'makeDict ';				 print: operator;				 cr.			self storePostscriptHexOn: inner.			inner print: $>;				 cr.			inner cr].	aStream cr! !!Form methodsFor: 'postscript generation' stamp: 'mpw 11/15/1999 08:34'!rowPadding	^ 32 // self depth! !!Form methodsFor: 'postscript generation'!setColorspaceOn: aStream 	self numComponents = 1		ifTrue: [aStream print: '/DeviceGray setcolorspace 0 setgray';				 cr]		ifFalse: [aStream print: '/DeviceRGB setcolorspace';				 cr]! !!Form methodsFor: 'postscript generation' stamp: 'nice 12/14/2013 14:46'!store15To24HexBitsOn: aStream 	"write data for 16-bit form, optimized for encoders writing directly to	files to do one single file write rather than 12. I'm not sure I	understand the significance of the shifting pattern, but I think I	faithfully translated it from the original"	| buf lineWidth |	lineWidth := 0.	buf := String new: 12.	self unhibernate.	bits		do: [:word | 			| i |			i := 0.			"upper pixel"			buf at: (i := i + 1) put: ((word bitShift: -27)					bitAnd: 15) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -32)					bitAnd: 8) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -22)					bitAnd: 15) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -27)					bitAnd: 8) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -17)					bitAnd: 15) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -22)					bitAnd: 8) asHexDigit.			"lower pixel"			buf at: (i := i + 1) put: ((word bitShift: -11)					bitAnd: 15) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -16)					bitAnd: 8) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -6)					bitAnd: 15) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -11)					bitAnd: 8) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -1)					bitAnd: 15) asHexDigit.			buf at: (i := i + 1) put: ((word bitShift: -6)					bitAnd: 8) asHexDigit.			aStream nextPutAll: buf.			lineWidth := lineWidth + 12.			lineWidth > 100				ifTrue: [aStream cr.					lineWidth := 0]]! !!Form methodsFor: 'postscript generation'!store32To24HexBitsOn: aStream 	^ self		storeBits: 20		to: 0		on: aStream! !!Form methodsFor: 'postscript generation' stamp: 'nice 12/14/2013 14:47'!storeBits: startBit to: stopBit on: aStream 	self unhibernate.	bits		storeBits: startBit		to: stopBit		on: aStream! !!Form methodsFor: 'postscript generation'!storeHexBitsOn: aStream 	^ self		storeBits: 28		to: 0		on: aStream! !!Form methodsFor: 'postscript generation' stamp: 'nk 12/31/2003 15:46'!storePostscriptHexOn: inner 	self depth <= 8		ifTrue: [self storeHexBitsOn: inner].	self depth = 16		ifTrue: [self store15To24HexBitsOn: inner].	self depth = 32		ifTrue: [self store32To24HexBitsOn: inner]! !!Form methodsFor: 'processing' stamp: 'tfel 4/17/2015 14:12'!approxGaussianBlur	^ self		processUsingKernel: (Matrix				rows: 3				columns: 3				contents: #(1 2 1 2 4 2 1 2 1 ) * 0.0625)! !!Form methodsFor: 'processing' stamp: 'tfel 4/17/2015 14:12'!edgeDetect	^ self		processUsingKernel: (Matrix				rows: 3				columns: 3				contents: #(-1 -1 -1 -1 8 -1 -1 -1 -1 ))! !!Form methodsFor: 'processing' stamp: 'tfel 4/17/2015 14:35'!emboss	^ self		processUsingKernel: (Matrix				rows: 3				columns: 3				contents: #(-2 -1 0 -1 1 1 0 1 2 ))! !!Form methodsFor: 'processing' stamp: 'tfel 4/17/2015 14:12'!processUsingKernel: filter 	^ self		processUsingKernel: filter		factor: 1.0		bias: 0.0! !!Form methodsFor: 'processing' stamp: 'tfel 4/17/2015 14:22'!processUsingKernel: filter factor: factor bias: bias 	| image result |	image := self.	result := Form extent: image extent depth: image depth.	0		to: image height - 1		do: [:y | 0				to: image width - 1				do: [:x | 					| r g b |					r := g := b := 0.0.					0						to: filter rowCount - 1						do: [:filterY | 0								to: filter columnCount - 1								do: [:filterX | 									| imageX imageY |									imageX := x - (filter columnCount // 2) + filterX + image width \\ image width.									imageY := y - (filter rowCount // 2) + filterY + image height \\ image height.									r := r + ((image colorAt: imageX @ imageY) red													* (filter at: filterY + 1 at: filterX + 1)).									g := g + ((image colorAt: imageX @ imageY) green													* (filter at: filterY + 1 at: filterX + 1)).									b := b + ((image colorAt: imageX @ imageY) blue													* (filter at: filterY + 1 at: filterX + 1))]].					result						colorAt: x @ y						put: (Color								r: (factor * r + bias min: 1.0 max: 0.0)								g: (factor * g + bias min: 1.0 max: 0.0)								b: (factor * b + bias min: 1.0 max: 0.0))]].	^ result! !!Form methodsFor: 'processing' stamp: 'tfel 4/17/2015 14:12'!sharpen	^ self		processUsingKernel: (Matrix				rows: 3				columns: 3				contents: #(0 -1 0 -1 5 -1 0 -1 0 ))! !!Form methodsFor: 'resources' stamp: 'nice 7/26/2014 23:57'!readNativeResourceFrom: byteStream 	| img aStream |	aStream := byteStream.	img := [ImageReadWriter formFromStream: aStream]				on: Error				do: [:ex | nil].	img		ifNil: [^ nil].	(img isColorForm			and: [self isColorForm])		ifTrue: [| cc |			cc := img colors.			img colors: nil.			img displayOn: self.			img colors: cc]		ifFalse: [img displayOn: self].	img := nil! !!Form methodsFor: 'resources' stamp: 'fbs 7/25/2013 07:09'!readResourceFrom: aStream 	"Store a resource representation of the receiver on aStream.	Must be specific to the receiver so that no code is filed out."	| bitsSize msb |	(aStream next: 4) asString = self resourceTag		ifFalse: [aStream position: aStream position - 4.			^ self readNativeResourceFrom: aStream].	width := aStream nextNumber: 4.	height := aStream nextNumber: 4.	depth := aStream nextNumber: 4.	bitsSize := aStream nextNumber: 4.	bitsSize = 0		ifFalse: [bits := aStream next: bitsSize.			^ self].	msb := (aStream nextNumber: 4)				= 1.	bitsSize := aStream nextNumber: 4.	bits := Bitmap new: self bitsSize.	(Form		extent: width @ height		depth: depth		bits: (aStream next: bitsSize * 4))		displayOn: self.	msb = Smalltalk isBigEndian		ifFalse: [Bitmap				swapBytesIn: bits				from: 1				to: bits size]! !!Form methodsFor: 'resources' stamp: 'ar 2/27/2001 14:56'!resourceTag	^ 'FORM'! !!Form methodsFor: 'resources' stamp: 'fbs 7/25/2013 07:09'!storeResourceOn: aStream 	"Store a resource representation of the receiver on aStream.	Must be specific to the receiver so that no code is filed out."	self hibernate.	aStream nextPutAll: self resourceTag asByteArray.	"tag"	aStream nextNumber: 4 put: width.	aStream nextNumber: 4 put: height.	aStream nextNumber: 4 put: depth.	(bits isMemberOf: ByteArray)		ifFalse: ["must store bitmap"			aStream nextNumber: 4 put: 0.			"tag"			aStream				nextNumber: 4				put: (Smalltalk isBigEndian						ifTrue: [1]						ifFalse: [0])].	aStream nextNumber: 4 put: bits size.	aStream nextPutAll: bits! !!Form methodsFor: 'scaling, rotation' stamp: 'mt 4/19/2015 11:38'!clippedToSize: aPoint 	"Return a copy of this form that is clipped to the given size around the	center. "	| newForm |	newForm := self class extent: aPoint depth: depth.	^ newForm		copyBits: ((0 @ 0 corner: aPoint)				translateBy: self extent - aPoint // 2)		from: self		at: 0 @ 0		clippingBox: newForm boundingBox		rule: Form over		fillColor: nil! !!Form methodsFor: 'scaling, rotation' stamp: 'tpr 3/15/2013 12:41'!flipBy: direction centerAt: aPoint 	"Return a copy of the receiver flipped either #vertical or #horizontal."	| newForm quad |	newForm := self class extent: self extent depth: depth.	quad := self boundingBox innerCorners.	quad := (direction = #vertical				ifTrue: [#(2 1 4 3 )]				ifFalse: [#(4 3 2 1 )])				collect: [:i | quad at: i].	(WarpBlt toForm: newForm) sourceForm: self;				colorMap: (self colormapIfNeededFor: newForm);		 combinationRule: 3;		 copyQuad: quad toRect: newForm boundingBox.	newForm		offset: (self offset flipBy: direction centerAt: aPoint).	^ newForm"	[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))	flipBy: #vertical centerAt: 0@0) display	"	"Consistency test...	| f f2 p | [Sensor anyButtonPressed] whileFalse:	[f := Form fromDisplay: ((p := Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 := f flipBy: #vertical centerAt: 0@0.	(f2 flipBy: #vertical centerAt: 0@0) displayAt: p	"! !!Form methodsFor: 'scaling, rotation' stamp: 'tpr 9/28/2004 17:00'!magnifyBy: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float or even a Point, and may be greater or less than	1.0. "	^ self		magnify: self boundingBox		by: scale		smoothing: (scale < 1				ifTrue: [2]				ifFalse: [1])! !!Form methodsFor: 'scaling, rotation'!magnify: aRectangle by: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self		magnify: aRectangle		by: scale		smoothing: 1"Dynamic test...	[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 31@41) by: 5@3)	display] "	"Scaling test...	| f cp | f := Form fromDisplay: (Rectangle originFromUser: 100@100).	Display restoreAfter: [Sensor waitNoButton.	[Sensor anyButtonPressed] whileFalse:	[cp := Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent)	display]] "	"Consistency test...	| f f2 p | [Sensor anyButtonPressed] whileFalse:	[f := Form fromDisplay: ((p := Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 := f magnify: f boundingBox by: 5@3.	(f2 shrink: f2 boundingBox by: 5@3) displayAt: p	"! !!Form methodsFor: 'scaling, rotation' stamp: 'tpr 3/15/2013 12:41'!magnify: aRectangle by: scale smoothing: cellSize 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float or even a Point, and may be greater or less than	1.0. "	| newForm |	newForm := self blankCopyOf: aRectangle scaledBy: scale.	(WarpBlt toForm: newForm) sourceForm: self;				colorMap: (self colormapIfNeededFor: newForm);		 cellSize: cellSize;		 combinationRule: 3;		 copyQuad: aRectangle innerCorners toRect: newForm boundingBox.	"installs a new colormap if cellSize > 1"	^ newForm"Dynamic test...	[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5	smoothing: 2) display	"	"Scaling test...	| f cp | f := Form fromDisplay: (Rectangle originFromUser: 100@100).	Display restoreAfter: [Sensor waitNoButton.	[Sensor anyButtonPressed] whileFalse:	[cp := Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent	smoothing: 2) display]	"! !!Form methodsFor: 'scaling, rotation'!rotateBy: deg 	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	^ self rotateBy: deg smoothing: 1"	| a f | f := Form fromDisplay: (0@0 extent: 200@200). a := 0.	[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))	rotateBy: (a := a+5)) display].	f displa	"! !!Form methodsFor: 'scaling, rotation' stamp: 'tpr 3/15/2013 12:42'!rotateBy: direction centerAt: aPoint 	"Return a rotated copy of the receiver. 	direction = #none, #right, #left, or #pi"	| newForm quad rot scale |	direction == #none		ifTrue: [^ self].	scale := (direction = #pi				ifTrue: [width @ height]				ifFalse: [height @ width])				/ self extent.	newForm := self blankCopyOf: self boundingBox scaledBy: scale.	quad := self boundingBox innerCorners.	rot := #(#right #pi #left ) indexOf: direction.	(WarpBlt toForm: newForm) sourceForm: self;				colorMap: (self colormapIfNeededFor: newForm);		 combinationRule: 3;				copyQuad: ((1 + rot to: 4 + rot)				collect: [:i | quad atWrap: i])		toRect: newForm boundingBox.	newForm		offset: (self offset rotateBy: direction centerAt: aPoint).	^ newForm"	[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))	rotateBy: #left centerAt: 0@0) display	"	"Consistency test...	| f f2 p | [Sensor anyButtonPressed] whileFalse:	[f := Form fromDisplay: ((p := Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 := f rotateBy: #left centerAt: 0@0.	(f2 rotateBy: #right centerAt: 0@0) displayAt: p	"! !!Form methodsFor: 'scaling, rotation' stamp: 'tpr 3/15/2013 12:42'!rotateBy: deg magnify: scale smoothing: cellSize 	"Rotate the receiver by the indicated number of degrees and magnify.	scale can be a Point to make for interesting 3D effects"	"rot is the destination form, big enough for any angle."	| side rot warp r1 pts bigSide |	side := 1 + self extent r asInteger.	bigSide := (side asPoint * scale) rounded.	rot := self blankCopyOf: self boundingBox scaledBy: bigSide / self extent.	warp := (WarpBlt toForm: rot) sourceForm: self;								colorMap: (self colormapIfNeededFor: rot);				 cellSize: cellSize;				 combinationRule: Form paint.	"installs a new colormap if cellSize > 1"	r1 := (0 @ 0 extent: side @ side)				align: side @ side // 2				with: self boundingBox center.	"Rotate the corners of the source rectangle."	pts := r1 innerCorners				collect: [:pt | 					| p |					p := pt - r1 center.					r1 center x asFloat + (p x asFloat * deg degreeCos) + (p y asFloat * deg degreeSin) @ (r1 center y asFloat - (p x asFloat * deg degreeSin) + (p y asFloat * deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot"	| a f | f := Form fromDisplay: (0@0 extent: 200@200). a := 0.	[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))	rotateBy: (a := a+5) magnify: 0.75@2 smoothing: 2) display].	f displa	"! !!Form methodsFor: 'scaling, rotation' stamp: 'tpr 9/28/2004 16:55'!rotateBy: deg smoothing: cellSize 	"Rotate the receiver by the indicated number of degrees."	^ self		rotateBy: deg		magnify: 1		smoothing: cellSize"	| a f | f := Form fromDisplay: (0@0 extent: 200@200). a := 0.	[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))	rotateBy: (a := a+5) smoothing: 2) display].	f displa	"! !!Form methodsFor: 'scaling, rotation' stamp: 'mt 8/25/2015 10:41'!scaledToSize: numberOrPoint 	^ self scaledToSize: numberOrPoint smoothing: 2! !!Form methodsFor: 'scaling, rotation' stamp: 'mt 8/25/2015 10:41'!scaledToSize: numberOrPoint smoothing: factor 	| scale newExtent |	newExtent := numberOrPoint asPoint.	newExtent = self extent		ifTrue: [^ self copy].	(self height isZero			or: [self width isZero])		ifTrue: [^ self species extent: newExtent depth: self depth].	scale := newExtent x / self width min: newExtent y / self height.	^ self		magnify: self boundingBox		by: scale		smoothing: factor! !!Form methodsFor: 'scaling, rotation'!shrink: aRectangle by: scale 	| scalePt |	scalePt := scale asPoint.	^ self magnify: aRectangle by: 1.0 / scalePt x asFloat @ (1.0 / scalePt y asFloat)! !!Form methodsFor: 'testing' stamp: 'ar 5/15/2001 16:14'!hasNonStandardPalette	"Return true if the receiver has a non-standard palette.	Non-standard means that RGBA components may be located	at positions differing from the standard Squeak RGBA layout	at the receiver's depth."	^ false! !!Form methodsFor: 'testing' stamp: 'ar 7/21/2007 21:37'!isAllWhite	"Answer whether all bits in the receiver are white"	| word |	self unhibernate.	word := Color white pixelWordForDepth: self depth.	1		to: bits size		do: [:i | (bits at: i)					= word				ifFalse: [^ false]].	^ true! !!Form methodsFor: 'testing' stamp: 'ar 5/17/2001 15:46'!isBigEndian	"Return true if the receiver contains big endian pixels, meaning the	left-most pixel is stored in the most significant bits of a word."	^ depth > 0! !!Form methodsFor: 'testing' stamp: 'ar 5/28/2000 14:58'!isBltAccelerated: ruleInteger for: sourceForm 	"Return true if the receiver can perform accelerated blts operations by	itself "	^ false! !!Form methodsFor: 'testing' stamp: 'ar 5/28/2000 15:04'!isDisplayScreen	^ false! !!Form methodsFor: 'testing' stamp: 'ar 5/27/2000 16:54'!isExternalForm	^ false! !!Form methodsFor: 'testing' stamp: 'ar 5/28/2000 14:58'!isFillAccelerated: ruleInteger for: aColor 	"Return true if the receiver can perform accelerated fill operations by	itself "	^ false! !!Form methodsFor: 'testing' stamp: 'ar 10/30/2000 23:23'!isForm	^ true! !!Form methodsFor: 'testing' stamp: 'lpc 6/8/2016 11:35'!isGrayScale	^ false! !!Form methodsFor: 'testing' stamp: 'ar 5/17/2001 15:47'!isLittleEndian	"Return true if the receiver contains little endian pixels, meaning the	left-most pixel is stored in the least significant bits of a word."	^ depth < 0! !!Form methodsFor: 'testing' stamp: 'RAA 8/14/2000 10:00'!isStatic	^ false! !!Form methodsFor: 'testing' stamp: 'ar 2/10/2004 17:18'!isTranslucent	"Answer whether this form may be translucent"	^ self depth = 32! !!Form methodsFor: 'testing' stamp: 'ar 5/28/2000 14:58'!shouldPreserveContents	"Return true if the receiver should preserve it's contents when flagged	to be clean. Most forms can not be trivially restored by some drawing	operation but some may."	^ true! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:44'!fadeImageCoarse: otherImage at: topLeft 	"Display fadeImageCoarse: (Form fromDisplay: (40@40 extent:	300@300)) reverse at: 40@40"	| d pix |	d := self depth.	^ self		fadeImage: otherImage		at: topLeft		indexAndMaskDo: [:i :mask | 			| j |			i = 1				ifTrue: [pix := (1 bitShift: d)								- 1.					1						to: 8 // d - 1						do: [:q | pix := pix										bitOr: (pix bitShift: d * 4)]].			i <= 16				and: [j := i - 1 // 4 + 1.					(0 to: 28 by: 4)						do: [:k | mask bits								at: j + k								put: (pix										bitOr: (mask bits at: j + k))].					true]]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:45'!fadeImageFine: otherImage at: topLeft 	"Display fadeImageFine: (Form fromDisplay: (40@40 extent:	300@300)) reverse at: 40@40"	| d pix |	d := self depth.	^ self		fadeImage: otherImage		at: topLeft		indexAndMaskDo: [:i :mask | 			| j ii |			i = 1				ifTrue: [pix := (1 bitShift: d)								- 1.					1						to: 8 // d - 1						do: [:q | pix := pix										bitOr: (pix bitShift: d * 4)]].			i <= 16				and: [ii := #(0 10 2 8 7 13 5 15 1 11 3 9 6 12 4 14 ) at: i.					j := ii // 4 + 1.					(0 to: 28 by: 4)						do: [:k | mask bits								at: j + k								put: ((mask bits at: j + k)										bitOr: pix)].					true]]! !!Form methodsFor: 'transitions'!fadeImageHorFine: otherImage at: topLeft 	"Display fadeImageHorFine: (Form fromDisplay: (10@10 extent:	300@300)) reverse at: 10@10"	^ self		fadeImage: otherImage		at: topLeft		indexAndMaskDo: [:i :mask | 			mask				fill: (0 @ (i - 1) extent: mask width @ 1)				fillColor: Color black.			mask				fill: (0 @ (i - 1 + 16) extent: mask width @ 1)				fillColor: Color black.			i * 2 <= mask width]! !!Form methodsFor: 'transitions'!fadeImageHor: otherImage at: topLeft 	"Display fadeImageHor: (Form fromDisplay: (10@10 extent:	300@300)) reverse at: 10@10"	^ self		fadeImage: otherImage		at: topLeft		indexAndMaskDo: [:i :mask | 			mask				fill: (0 @ (mask height // 2 - i) extent: mask width @ (i * 2))				fillColor: Color black.			i * 2 <= mask width]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 16:29'!fadeImageSquares: otherImage at: topLeft 	"Display fadeImageSquares: (Form fromDisplay: (40@40 extent:	300@300)) reverse at: 40@40"	^ self		fadeImage: otherImage		at: topLeft		indexAndMaskDo: [:i :mask | 			mask				fill: ((16 - i) asPoint extent: (i * 2) asPoint)				fillColor: Color black.			i <= 16]! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:39'!fadeImageVert: otherImage at: topLeft 	"Display fadeImageVert: (Form fromDisplay: (10@10 extent:	300@300)) reverse at: 10@10"	| d |	d := self depth.	^ self		fadeImage: otherImage		at: topLeft		indexAndMaskDo: [:i :mask | 			mask				fill: (mask width // 2 // d - i * d @ 0 extent: i * 2 * d @ mask height)				fillColor: Color black.			i <= (mask width // d)]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:43'!fadeImage: otherImage at: topLeft indexAndMaskDo: indexAndMaskBlock 	"This fade uses halftones as a blending hack.	Zeros in the halftone produce the original image (self), and 	ones in the halftone produce the 'otherImage'.	IndexAndMaskBlock gets evaluated prior to each cycle,	and the resulting boolean determines whether to continue cycling."	| index imageRect maskForm resultForm pix returnPix |	imageRect := otherImage boundingBox.	resultForm := self				copy: (topLeft extent: imageRect extent).	maskForm := Form extent: 32 @ 32.	index := 0.	[indexAndMaskBlock value: (index := index + 1) value: maskForm]		whileTrue: [maskForm reverse.			resultForm				copyBits: imageRect				from: resultForm				at: 0 @ 0				clippingBox: imageRect				rule: Form over				fillColor: maskForm.			maskForm reverse.			resultForm				copyBits: imageRect				from: otherImage				at: 0 @ 0				clippingBox: imageRect				rule: Form under				fillColor: maskForm.			self				copyBits: imageRect				from: resultForm				at: topLeft				clippingBox: self boundingBox				rule: Form over				fillColor: nil.			Display forceDisplayUpdate]! !!Form methodsFor: 'transitions' stamp: 'nice 12/29/2010 14:46'!pageImage: otherImage at: topLeft corner: corner 	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form. Corner specifies which corner, as	1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize := 10.	bb := otherImage boundingBox.	resultForm := self				copy: (topLeft extent: bb extent).	maskForm := Form extent: ((otherImage width min: otherImage height)					+ stepSize) asPoint.	"maskLoc := starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."			(corner between: 2 and: 3) not				ifTrue: ["motion is to the right"					delta := 1 @ 0.					maskLoc := bb topLeft								- (corner = 1										ifTrue: [maskForm width @ 0]										ifFalse: [maskForm width @ stepSize])]				ifFalse: ["motion is to the left"					delta := -1 @ 0.					maskLoc := bb topRight								- (corner = 2										ifTrue: [0 @ 0]										ifFalse: [0 @ stepSize])]]		ifFalse: ["tall image; motion is vertical."			corner <= 2				ifTrue: ["motion is downward"					delta := 0 @ 1.					maskLoc := bb topLeft								- (corner = 1										ifTrue: [0 @ maskForm height]										ifFalse: [stepSize @ maskForm height])]				ifFalse: ["motion is upward"					delta := 0 @ -1.					maskLoc := bb bottomLeft								- (corner = 3										ifTrue: [stepSize @ 0]										ifFalse: [0 @ 0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm)		in: [:p | corner even				ifTrue: ["Draw 45-degree line"					p place: 0 @ 0;						 turn: 135;						 go: maskForm width * 3 // 2]				ifFalse: [p place: 0 @ (maskForm height - 1);						 turn: 45;						 go: maskForm width * 3 // 2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed. Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm := (Form extent: maskForm extent depth: otherImage depth)				copyBits: maskForm boundingBox				from: maskForm				at: 0 @ 0				colorMap: (Bitmap with: 4294967295 with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft ) at: corner.	1		to: otherImage width + otherImage height // stepSize + 1		do: [:i | 			"Determine the affected square"			maskRect := (maskLoc extent: maskForm extent)						intersect: bb.			maskLoc x * delta x + (maskLoc y * delta y) < 0				ifTrue: [smallRect := 0 @ 0 extent: (maskRect width min: maskRect height) asPoint.					maskRect := smallRect								align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].			"AND otherForm with triangle mask, and OR into result"			resultForm				copyBits: bb				from: otherImage				at: 0 @ 0				clippingBox: maskRect				rule: Form over				fillColor: nil.			resultForm				copyBits: maskForm boundingBox				from: maskForm				at: maskLoc				clippingBox: maskRect				rule: Form erase				fillColor: nil.			resultForm				copyBits: maskForm boundingBox				from: maskForm				at: maskLoc				clippingBox: maskRect				rule: Form under				fillColor: Color lightBrown.			"Now update Display in a single BLT."			self				copyBits: maskRect				from: resultForm				at: topLeft + maskRect topLeft				clippingBox: self boundingBox				rule: Form over				fillColor: nil.			Display forceDisplayUpdate.			maskLoc := maskLoc + (delta * stepSize)			"			1 to: 4 do: [:corner | Display pageImage:			(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner			"]! !!Form methodsFor: 'transitions' stamp: 'tpr 3/15/2013 12:42'!pageWarp: otherImage at: topLeft forward: forward 	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.	forward == true means turn pages toward you, else away. [ignored	for now]"	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |	pageRect := otherImage boundingBox.	oldPage := self				copy: (pageRect translateBy: topLeft).	(forward		ifTrue: [oldPage]		ifFalse: [otherImage])		border: pageRect		widthRectangle: (Rectangle				left: 0				right: 2				top: 1				bottom: 1)		rule: Form over		fillColor: Color black.	oldBottom := self				copy: (pageRect bottomLeft + topLeft extent: pageRect width @ (pageRect height // 4)).	nSteps := 8.	buffer := Form extent: otherImage extent + (0 @ (pageRect height // 4)) depth: self depth.	d := pageRect topLeft + (0 @ (pageRect height // 4)) - pageRect topRight.	1		to: nSteps - 1		do: [:i | 			forward				ifTrue: [buffer						copy: pageRect						from: otherImage						to: 0 @ 0						rule: Form over.					p := pageRect topRight + (d * i // nSteps)]				ifFalse: [buffer						copy: pageRect						from: oldPage						to: 0 @ 0						rule: Form over.					p := pageRect topRight + (d * (nSteps - i) // nSteps)].			buffer				copy: oldBottom boundingBox				from: oldBottom				to: pageRect bottomLeft				rule: Form over.			leafRect := pageRect topLeft corner: p x @ (pageRect bottom + p y).			sourceQuad := Array						with: pageRect topLeft						with: pageRect bottomLeft + (0 @ p y)						with: pageRect bottomRight						with: pageRect topRight - (0 @ p y).			warp := (WarpBlt toForm: buffer) clipRect: leafRect;												sourceForm: (forward								ifTrue: [oldPage]								ifFalse: [otherImage]);						 combinationRule: Form paint.			warp copyQuad: sourceQuad toRect: leafRect.			self				copy: buffer boundingBox				from: buffer				to: topLeft				rule: Form over.			Display forceDisplayUpdate].	buffer		copy: pageRect		from: otherImage		to: 0 @ 0		rule: Form over.	buffer		copy: oldBottom boundingBox		from: oldBottom		to: pageRect bottomLeft		rule: Form over.	self		copy: buffer boundingBox		from: buffer		to: topLeft		rule: Form over.	Display forceDisplayUpdate! !!Form methodsFor: 'transitions' stamp: 'jm 5/21/1998 23:46'!slideImage: otherImage at: topLeft delta: delta 	"Display slideImage: (Form fromDisplay: (40@40 extent: 300@300))	reverse at: 40@40 delta: 3@-4"	| bb nSteps clipRect |	bb := otherImage boundingBox.	clipRect := topLeft extent: otherImage extent.	nSteps := 1.	delta x = 0		ifFalse: [nSteps := nSteps max: bb width // delta x abs + 1].	delta y = 0		ifFalse: [nSteps := nSteps max: bb height // delta y abs + 1].	1		to: nSteps		do: [:i | 			self				copyBits: bb				from: otherImage				at: delta * (i - nSteps) + topLeft				clippingBox: clipRect				rule: Form paint				fillColor: nil.			Display forceDisplayUpdate]! !!Form methodsFor: 'transitions' stamp: 'jm 6/18/1998 12:57'!wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock 	| i clipRect t rectOrList waitTime |	i := 0.	clipRect := topLeft extent: otherImage extent.	clipBox		ifNotNil: [clipRect := clipRect intersect: clipBox].	[rectOrList := rectForIndexBlock value: (i := i + 1).	rectOrList == nil]		whileFalse: [t := Time millisecondClockValue.			rectOrList asOrderedCollection				do: [:r | self						copyBits: r						from: otherImage						at: topLeft + r topLeft						clippingBox: clipRect						rule: Form over						fillColor: nil].			Display forceDisplayUpdate.			waitTime := 3 - (Time millisecondClockValue - t).			waitTime > 0				ifTrue: ["(Delay forMilliseconds: waitTime) wait"					]]! !!Form methodsFor: 'transitions' stamp: 'jm 10/16/97 15:21'!wipeImage: otherImage at: topLeft delta: delta 	"Display wipeImage: (Form fromDisplay: (40@40 extent: 300@300))	reverse at: 40@40 delta: 0@-2"	self		wipeImage: otherImage		at: topLeft		delta: delta		clippingBox: nil! !!Form methodsFor: 'transitions' stamp: 'jm 10/16/97 15:17'!wipeImage: otherImage at: topLeft delta: delta clippingBox: clipBox 	| wipeRect bb nSteps |	bb := otherImage boundingBox.	wipeRect := delta x = 0				ifTrue: [delta y = 0						ifTrue: [nSteps := 1.							bb							"allow 0@0"]						ifFalse: [nSteps := bb height // delta y abs + 1.							"Vertical movement"							delta y > 0								ifTrue: [bb topLeft extent: bb width @ delta y]								ifFalse: [bb bottomLeft + delta extent: bb width @ delta y negated]]]				ifFalse: [nSteps := bb width // delta x abs + 1.					"Horizontal movement"					delta x > 0						ifTrue: [bb topLeft extent: delta x @ bb height]						ifFalse: [bb topRight + delta extent: delta x negated @ bb height]].	^ self		wipeImage: otherImage		at: topLeft		clippingBox: clipBox		rectForIndex: [:i | i <= nSteps				ifTrue: [wipeRect translateBy: delta * (i - 1)]]! !!Form methodsFor: 'transitions' stamp: 'di 3/2/98 09:14'!zoomInTo: otherImage at: topLeft 	"Display zoomInTo: (Form fromDisplay: (40@40 extent: 300@300))	reverse at: 40@40"	^ self		zoomIn: true		orOutTo: otherImage		at: topLeft		vanishingPoint: otherImage extent // 2 + topLeft! !!Form methodsFor: 'transitions' stamp: 'nice 12/27/2009 03:10'!zoomIn: goingIn orOutTo: otherImage at: topLeft vanishingPoint: vp 	"Display zoomInTo: (Form fromDisplay: (40@40 extent: 300@300))	reverse at: 40@40.	Display zoomOutTo: (Form fromDisplay: (40@40 extent: 300@300))	reverse at: 40@40."	| nSteps minTime startTime |	nSteps := 16.	minTime := 500.	"milliseconds"	startTime := Time millisecondClockValue.	^ self		wipeImage: otherImage		at: topLeft		clippingBox: nil		rectForIndex: [:i | | lead bigR j lilR | "i runs from 1 to nsteps"			i > nSteps				ifFalse: ["If we are going too fast, delay for a bit"					lead := startTime + (i - 1 * minTime // nSteps) - Time millisecondClockValue.					lead > 10						ifTrue: [(Delay forMilliseconds: lead) wait].					"Return an array with the difference rectangles for this					step. "					j := goingIn								ifTrue: [i]								ifFalse: [nSteps + 1 - i].					bigR := vp - (vp * j // nSteps) corner: vp + (otherImage extent - vp * j // nSteps).					lilR := vp - (vp * (j - 1) // nSteps) corner: vp + (otherImage extent - vp * (j - 1) // nSteps).					bigR areasOutside: lilR]]! !!Form methodsFor: 'transitions' stamp: 'di 3/2/98 09:15'!zoomOutTo: otherImage at: topLeft 	"Display zoomOutTo: (Form fromDisplay: (40@40 extent: 300@300))	reverse at: 40@40"	^ self		zoomIn: false		orOutTo: otherImage		at: topLeft		vanishingPoint: otherImage extent // 2 + topLeft! !!Form methodsFor: 'private' stamp: 'tk 3/13/2000 15:21'!hackBits: bitThing 	"This method provides an initialization so that BitBlt may be used, eg,	to 	copy ByteArrays and other non-pointer objects efficiently.	The resulting form looks 4 wide, 8 deep, and bitThing-size-in-words	high. "	width := 4.	depth := 8.	bitThing class isBits		ifFalse: [self error: 'bitThing must be a non-pointer object'].	bitThing class isBytes		ifTrue: [height := bitThing basicSize // 4]		ifFalse: [height := bitThing basicSize].	bits := bitThing! !!Form methodsFor: 'private'!initFromArray: array 	"Fill the bitmap from array. If the array is shorter,	then cycle around in its contents until the bitmap is filled."	| ax aSize array32 i j word16 |	ax := 0.	aSize := array size.	aSize > bits size		ifTrue: ["backward compatibility with old 16-bit bitmaps and their			forms "			array32 := Array new: height * (width + 31 // 32).			i := j := 0.			1				to: height				do: [:y | 1						to: width + 15 // 16						do: [:x16 | 							word16 := array at: (i := i + 1).							x16 odd								ifTrue: [array32										at: (j := j + 1)										put: (word16 bitShift: 16)]								ifFalse: [array32										at: j										put: ((array32 at: j)												bitOr: word16)]]].			^ self initFromArray: array32].	1		to: bits size		do: [:index | 			(ax := ax + 1) > aSize				ifTrue: [ax := 1].			bits				at: index				put: (array at: ax)]! !!Form methodsFor: 'private' stamp: 'ar 12/19/2000 16:23'!privateFloodFillValue: aColor 	"Private. Compute the pixel value in the receiver's depth but take into	account implicit color conversions by BitBlt."	| f1 f2 bb |	f1 := Form extent: 1 @ 1 depth: depth.	f2 := Form extent: 1 @ 1 depth: 32.	bb := BitBlt toForm: f1.	bb fillColor: aColor;				destRect: (0 @ 0 corner: 1 @ 1);		 combinationRule: 3;		 copyBits.	bb := BitBlt toForm: f2.	bb sourceForm: f1;		 sourceOrigin: 0 @ 0;				destRect: (0 @ 0 corner: 1 @ 1);		 combinationRule: 3;		 copyBits.	^ f2 pixelValueAt: 0 @ 0! !!Form methodsFor: 'private' stamp: '6/9/97 16:10 di'!setExtent: extent depth: bitsPerPixel 	"Create a virtual bit map with the given extent and bitsPerPixel."	width := extent x asInteger.	width < 0		ifTrue: [width := 0].	height := extent y asInteger.	height < 0		ifTrue: [height := 0].	depth := bitsPerPixel.	bits := Bitmap new: self bitsSize! !!Form methodsFor: 'private' stamp: 'tfel 7/27/2016 15:17'!setExtent: extent depth: bitsPerPixel bits: bitmap 	"Create a virtual bit map with the given extent and bitsPerPixel."	width := extent x asInteger.	width < 0		ifTrue: [width := 0].	height := extent y asInteger.	height < 0		ifTrue: [height := 0].	depth := bitsPerPixel.	depth := bitsPerPixel.	(bits isNil			or: [(bitmap class isWords						and: [self bitsSize = bitmap size])					or: [bitmap class isBytes							and: [self bitsSize * 4 = bitmap size]]])		ifFalse: [^ self error: 'Bad dimensions'].	bits := bitmap! !!Form methodsFor: 'private' stamp: 'ar 10/30/2000 23:22'!setResourceBits: aForm 	"Private. Really. Used for setting the 'resource bits' when externalizing	some form"	bits := aForm! !!Form methodsFor: '*seaside-pharo-core' stamp: 'jf 9/22/2008 13:21'!defaultMimeType	^ WAMimeType imageGif! !!Form methodsFor: '*seaside-pharo-core' stamp: 'mb 6/12/2006 14:01'!mimeType	^ self defaultMimeType! !!Form methodsFor: '*seaside-pharo-core' stamp: 'lr 10/18/2008 16:39'!seasideMimeDocument	^ self seasideMimeDocumentType: self defaultMimeType! !!Form methodsFor: '*seaside-pharo-core' stamp: 'pmm 6/19/2010 08:30'!seasideMimeDocumentType: aMimeType 	"Converts the receiver to a WAMimeDocument. The argument should	ideally be an instance for WAMimeType. For various crappy reasons	Strings and nil are also allowed."	| aStream writer |	aStream := RWBinaryOrTextStream on: String new.	writer := self writerForMimeType: aMimeType seasideMimeType.	writer isNil		ifTrue: [self error: 'no writer for ' , aMimeType greaseString , ' found'].	writer		putForm: (self asFormOfDepth: 32)		onStream: aStream.	^ WAMimeDocument on: aStream contents mimeType: aMimeType! !!Form methodsFor: '*seaside-pharo-core' stamp: 'pmm 4/2/2012 19:16'!writerForMimeType: mimeType 	| sub |	mimeType main ~= 'image'		ifTrue: [^ nil].	"First token is assumed to be 'image'"	sub := mimeType sub.	(sub = 'jpg'			or: [sub = 'jpeg'])		ifTrue: ["try PluginBasedJPEGReadWriter, JPEGReadWriter2 and			JPEGReadWriter "			^ Smalltalk				at: #PluginBasedJPEGReadWriter				ifAbsent: [Smalltalk						at: #JPEGReadWriter2						ifAbsent: [Smalltalk								at: #JPEGReadWriter								ifAbsent: []]]].	sub = 'png'		ifTrue: [^ PNGReadWriter].	sub = 'bmp'		ifTrue: [^ BMPReadWriter].	sub = 'gif'		ifTrue: [^ GIFReadWriter].	^ nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Form class	instanceVariableNames: ''!!Form class methodsFor: '*Morphic-examples' stamp: 'tpr 11/13/2015 15:36'!exampleColorSees	"Form exampleColorSees"	"First column as above shows the sneaky red/yellow pirate sneaking up	on the blue/peach galleon.	Second column shows the 1bpp made from the	red/yellow/transparent - white -> ignore this, black -> test this	Third shows the hit area - where red touches blue - superimposed on	the original scene.	Fourth column is the tally of hits via the old algorithm	Last column shows the tally of hits via the new prim"	| formA formB maskA offset tally map intersection left top dCanvas sensitiveColor soughtColor index |	formA := formB := maskA := offset := tally := map := intersection := nil.	"just to shut up the compiler when testing"	ActiveWorld restoreMorphicDisplay; doOneCycle.	sensitiveColor := Color red.	soughtColor := Color blue.	top := 50.	dCanvas := FormCanvas on: Display.	-50		to: 80		by: 10		do: [:p | 			offset := p @ 0.			"vary this to check different states"			left := 10.			formA := (Form extent: 100 @ 50 depth: 32)						asFormOfDepth: 16.			"so we can try original forms of other depths"			formB := Form extent: 100 @ 50 depth: 32.			"make a red square in the middle of the form"			(FormCanvas on: formA)				fillRectangle: (25 @ 25 extent: 50 @ 5)				fillStyle: sensitiveColor.			(FormCanvas on: formA)				fillRectangle: (25 @ 30 extent: 50 @ 5)				fillStyle: Color transparent.			(FormCanvas on: formA)				fillRectangle: (25 @ 35 extent: 50 @ 50)				fillStyle: Color yellow.			"formA displayOn: Display at: left@top rule: Form paint.			dCanvas frameRectangle: (left@top extent: formA extent)			width:2 color: Color green.			left := left + 150."			"make a blue block on the right half of the form"			(FormCanvas on: formB)				fillRectangle: (50 @ 0 extent: 50 @ 100)				fillStyle: soughtColor.			(FormCanvas on: formB)				fillRectangle: (60 @ 0 extent: 10 @ 100)				fillStyle: Color palePeach.			"formB displayOn: Display at: left@top rule: Form paint.			dCanvas frameRectangle: (left@top extent: formA extent)			width:2 color: Color green.			left := left + 150."			intersection := (formA boundingBox translateBy: offset)						intersect: formB boundingBox.			formB				displayOn: Display				at: left @ top				rule: Form paint.			formA				displayOn: Display				at: left @ top + offset				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 150.			maskA := Form extent: intersection extent depth: 1.			map := Bitmap						new: (1								bitShift: (formA depth min: 15)).			map at: (index := sensitiveColor indexInMap: map) put: 1.			maskA				copyBits: (intersection translateBy: offset negated)				from: formA				at: 0 @ 0				colorMap: map.			formB				displayOn: Display				at: left @ top				rule: Form paint.			formA				displayOn: Display				at: left @ top + offset				rule: Form paint.			maskA				displayOn: Display				at: left @ top + intersection origin				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 150.			"intersect world pixels of the color we're looking for with			sensitive pixels mask"			map at: index put: 0.			"clear map and reuse it"			map				at: (soughtColor indexInMap: map)				put: 1.			maskA				copyBits: intersection				from: formB				at: 0 @ 0				clippingBox: formB boundingBox				rule: Form and				fillColor: nil				map: map.			formB				displayOn: Display				at: left @ top				rule: Form paint.			formA				displayOn: Display				at: left @ top + offset				rule: Form paint.			maskA				displayOn: Display				at: left @ top + intersection origin				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 170.			(maskA tallyPixelValues at: 2) asString asDisplayText displayOn: Display at: left @ (top + 20).			left := left + 70.			"now try using the new primitive"			tally := (BitBlt						destForm: formB						sourceForm: formA						fillColor: nil						combinationRule: 3						destOrigin: intersection origin						sourceOrigin: (offset negated max: 0 @ 0)						extent: intersection extent						clipRect: intersection)						primCompareColor: (sensitiveColor pixelValueForDepth: formA depth)						to: (soughtColor pixelValueForDepth: formB depth)						test: (Form compareMatchColor bitOr: Form compareTallyFlag).			"really ought to work with nil but prim code checks"			tally asString asDisplayText displayOn: Display at: left @ (top + 20).			top := top + 60]! !!Form class methodsFor: '*Morphic-examples' stamp: 'tpr 11/13/2015 15:36'!exampleTouchTest	"Form exampleTouchTest"	"Demonstrate the algorithm used in Scratch code to determine if a	sprite's non-transparent pixels touch a 	non-transparent pixel of the background upon which it is displayed.	First column shows a form with a red block in the midst of	transparent area sneaking up on a form with a transparent LHS and	blue RHS. The green frame shows the intersection area.	Second column shows in grey the part of the red that is within the	intersection. Third column shows in black the blue that is within the	intersection. Fourth column shows just the A touching B area.	Fifth column is the tally of hits via the old algorithm	Last column shows the tally of hits via the new prim"	| formA formB maskA maskB offset tally map intersection left top dCanvas |	formA := formB := maskA := maskB := offset := tally := map := intersection := nil.	"just to shut up the compiler when testing"	ActiveWorld restoreMorphicDisplay; doOneCycle.	top := 50.	dCanvas := FormCanvas on: Display.	-50		to: 80		by: 10		do: [:p | 			offset := p @ 0.			"vary this to check different states"			left := 10.			formA := Form extent: 100 @ 50 depth: 32.			formB := Form extent: 100 @ 50 depth: 16.			"make a red square in the middle of the form"			(FormCanvas on: formA)				fillRectangle: (25 @ 25 extent: 50 @ 5)				fillStyle: Color yellow.			(FormCanvas on: formA)				fillRectangle: (25 @ 30 extent: 50 @ 5)				fillStyle: Color transparent.			(FormCanvas on: formA)				fillRectangle: (25 @ 35 extent: 50 @ 50)				fillStyle: Color red.			"formA displayOn: Display at: left@top rule: Form paint.			dCanvas frameRectangle: (left@top extent: formA extent)			width:2 color: Color green.			left := left + 150."			"make a blue block on the right half of the form"			(FormCanvas on: formB)				fillRectangle: (50 @ 0 extent: 50 @ 100)				fillStyle: Color blue.			(FormCanvas on: formB)				fillRectangle: (60 @ 0 extent: 10 @ 100)				fillStyle: Color palePeach.			"formB displayOn: Display at: left@top rule: Form paint.			dCanvas frameRectangle: (left@top extent: formA extent)			width:2 color: Color green.			left := left + 150."			intersection := (formA boundingBox translateBy: offset)						intersect: formB boundingBox.			formB				displayOn: Display				at: left @ top				rule: Form paint.			formA				displayOn: Display				at: left @ top + offset				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 150.			maskA := Form extent: intersection extent depth: 2.			formA				displayOn: maskA				at: offset - intersection origin				rule: Form paint.			formB				displayOn: Display				at: left @ top				rule: Form paint.			formA				displayOn: Display				at: left @ top + offset				rule: Form paint.			maskA				displayOn: Display				at: left @ top + intersection origin				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 150.			maskB := Form extent: intersection extent depth: 2.			formB				displayOn: maskB				at: intersection origin negated				rule: Form paint.			formB				displayOn: Display				at: left @ top				rule: Form paint.			formA				displayOn: Display				at: left @ top + offset				rule: Form paint.			maskB				displayOn: Display				at: left @ top + intersection origin				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 150.			map := Bitmap new: 4 withAll: 1.			map at: 1 put: 0.			"transparent"			maskA				copyBits: maskA boundingBox				from: maskA				at: 0 @ 0				colorMap: map.			"maskA displayOn: Display at: (left@top) + intersection origin			rule: Form paint.			dCanvas frameRectangle: (intersection translateBy: left@top)			width:2 color: Color green.			left := left + 150."			maskB				copyBits: maskB boundingBox				from: maskB				at: 0 @ 0				colorMap: map.			"maskB displayOn: Display at: (left@top) + intersection origin			rule: Form paint.			dCanvas frameRectangle: (intersection translateBy: left@top)			width:2 color: Color green.			left := left + 150."			maskB				displayOn: maskA				at: 0 @ 0				rule: Form and.			maskA				displayOn: Display				at: left @ top + intersection origin				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 170.			(maskA boundingBox area				- (maskA tallyPixelValues at: 1)) asString asDisplayText displayOn: Display at: left @ (top + 20).			left := left + 70.			"now try using the new primitive"			tally := (BitBlt						destForm: formB						sourceForm: formA						fillColor: nil						combinationRule: 3						destOrigin: intersection origin						sourceOrigin: (offset negated max: 0 @ 0)						extent: intersection extent						clipRect: intersection)						primCompareColor: ((Color transparent pixelValueForDepth: formA depth)								bitAnd: 16777215)						to: ((Color transparent pixelValueForDepth: formB depth)								bitAnd: 16777215)						test: (Form compareNotColorANotColorB bitOr: Form compareTallyFlag).			"really ought to work with nil but prim code checks"			tally asString asDisplayText displayOn: Display at: left @ (top + 20).			top := top + 60]! !!Form class methodsFor: '*Morphic-examples' stamp: 'tpr 11/13/2015 15:37'!exampleTouchingColor	"Form exampleTouchingColor"	"Demonstrate the algorithm used in Scratch code to determine if a	sprite's non-transparent pixels touch a	particular color pixel of the background upon which it is displayed.	First column as above shows the sneaky red/yellow pirate sneaking up	on the blue/peach galleon.	Second column shows the 1bpp made from the	red/yellow/transparent - white -> ignore this, black -> test this	Third shows the hit area (black) superimposed on the original scene	Fourth column is the tally of hits via the old algorithm	Last column shows the tally of hits via the new prim"	| formA formB maskA offset tally map intersection left top dCanvas ignoreColor soughtColor |	formA := formB := maskA := offset := tally := map := intersection := nil.	"just to shut up the compiler when testing"	ActiveWorld restoreMorphicDisplay; doOneCycle.	ignoreColor := Color transparent.	soughtColor := Color blue.	top := 50.	dCanvas := FormCanvas on: Display.	-50		to: 80		by: 10		do: [:p | 			offset := p @ 0.			"vary this to check different states"			left := 10.			formA := (Form extent: 100 @ 50 depth: 32)						asFormOfDepth: 16.			"so we can try original forms of other depths"			formB := Form extent: 100 @ 50 depth: 32.			"make a red square in the middle of the form"			(FormCanvas on: formA)				fillRectangle: (25 @ 25 extent: 50 @ 5)				fillStyle: Color red.			(FormCanvas on: formA)				fillRectangle: (25 @ 30 extent: 50 @ 5)				fillStyle: Color transparent.			(FormCanvas on: formA)				fillRectangle: (25 @ 35 extent: 50 @ 50)				fillStyle: Color yellow.			"formA displayOn: Display at: left@top rule: Form paint.			dCanvas frameRectangle: (left@top extent: formA extent)			width:2 color: Color green.			left := left + 150."			"make a blue block on the right half of the form"			(FormCanvas on: formB)				fillRectangle: (50 @ 0 extent: 50 @ 100)				fillStyle: soughtColor.			(FormCanvas on: formB)				fillRectangle: (60 @ 0 extent: 10 @ 100)				fillStyle: Color palePeach.			"formB displayOn: Display at: left@top rule: Form paint.			dCanvas frameRectangle: (left@top extent: formA extent)			width:2 color: Color green.			left := left + 150."			intersection := (formA boundingBox translateBy: offset)						intersect: formB boundingBox.			formB				displayOn: Display				at: left @ top				rule: Form paint.			formA				displayOn: Display				at: left @ top + offset				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 150.			maskA := Form extent: intersection extent depth: 1.			map := Bitmap						new: (1								bitShift: (formA depth min: 15)).			map atAllPut: 1.			map				at: (ignoreColor indexInMap: map)				put: 0.			maskA				copyBits: (intersection translateBy: offset negated)				from: formA				at: 0 @ 0				colorMap: map.			formB				displayOn: Display				at: left @ top				rule: Form paint.			formA				displayOn: Display				at: left @ top + offset				rule: Form paint.			maskA				displayOn: Display				at: left @ top + intersection origin				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 150.			"intersect world pixels of the color we're looking for with			sensitive pixels mask"			map atAllPut: 0.			"clear map and reuse it"			map				at: (soughtColor indexInMap: map)				put: 1.			maskA				copyBits: intersection				from: formB				at: 0 @ 0				clippingBox: formB boundingBox				rule: Form and				fillColor: nil				map: map.			formB				displayOn: Display				at: left @ top				rule: Form paint.			formA				displayOn: Display				at: left @ top + offset				rule: Form paint.			maskA				displayOn: Display				at: left @ top + intersection origin				rule: Form paint.			dCanvas				frameRectangle: (intersection translateBy: left @ top)				width: 2				color: Color green.			left := left + 170.			(maskA tallyPixelValues at: 2) asString asDisplayText displayOn: Display at: left @ (top + 20).			left := left + 70.			"now try using the new primitive"			tally := (BitBlt						destForm: formB						sourceForm: formA						fillColor: nil						combinationRule: 3						destOrigin: intersection origin						sourceOrigin: (offset negated max: 0 @ 0)						extent: intersection extent						clipRect: intersection)						primCompareColor: ((ignoreColor pixelValueForDepth: formA depth)								bitAnd: 16777215)						to: ((soughtColor pixelValueForDepth: formB depth)								bitAnd: 16777215)						test: (Form compareNotColorAMatchColorB bitOr: Form compareTallyFlag).			"really ought to work with nil but prim code checks"			tally asString asDisplayText displayOn: Display at: left @ (top + 20).			top := top + 60]! !!Form class methodsFor: 'BMP file reading' stamp: 'ar 6/16/2002 17:41'!fromBMPFile: aBinaryStream 	"Obsolete"	^ self fromBinaryStream: aBinaryStream! !!Form class methodsFor: 'BMP file reading' stamp: 'ar 6/16/2002 17:41'!fromBMPFileNamed: fileName 	"Obsolete"	^ self fromFileNamed: fileName! !!Form class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:09'!unload	FileServices unregisterFileReader: self! !!Form class methodsFor: 'examples' stamp: 'nice 1/10/2010 17:41'!exampleBorder	"Form exampleBorder"	"This example demonstrates the border finding algorithm. Start	by having the user sketch on the screen (end with option-click) and	then select a rectangular	area of the screen which includes all of the area to be filled. Finally,	(with crosshair cursor), the user points at the interior of the region to	be outlined, and the region begins with that place as its seed."	| f r interiorPoint |	Form exampleSketch.	"sketch a little area with an enclosed region"	r := Rectangle fromUser.	f := Form fromDisplay: r.	interiorPoint := Cursor crossHair				showWhile: [Sensor waitButton - r origin].	Cursor execute		showWhile: [f				shapeBorder: Color blue				width: 2				interiorPoint: interiorPoint				sharpCorners: false				internal: false].	f displayOn: Display at: r origin! !!Form class methodsFor: 'examples'!exampleEdits	"In Form category editing are messages edit and bitEdit that make it	possible to 	create editors on instances of Form. 		This is the general form editor:	| f | 	f := Form fromUser. 	f edit. 		This is the general bit editor:	| f | 	f := Form fromUser. 	f bitEdit."	^ self! !!Form class methodsFor: 'examples'!exampleMagnify	| f m |	f := Form fromUser.	m := f magnify: f boundingBox by: 5 @ 5.	m displayOn: Display at: Sensor waitButton	"Form exampleMagnify."! !!Form class methodsFor: 'examples'!exampleShrink	| f s |	f := Form fromUser.	s := f shrink: f boundingBox by: 2 @ 5.	s displayOn: Display at: Sensor waitButton	"Form exampleShrink."! !!Form class methodsFor: 'examples'!exampleSketch	"This is a simple drawing algorithm to get a sketch on the display	screen. Draws whenever mouse button down. Ends with option-click."	| aPen color |	aPen := Pen new.	color := 0.	[Sensor yellowButtonPressed]		whileFalse: [aPen place: Sensor cursorPoint;				 color: (color := color + 1).			[Sensor redButtonPressed]				whileTrue: [aPen goto: Sensor cursorPoint]].	Sensor waitNoButton! !!Form class methodsFor: 'examples' stamp: 'nice 1/10/2010 17:41'!exampleSpaceFill	"Form exampleSpaceFill"	"This example demonstrates the area filling algorithm. Starts by having	the user sketch on the screen (ended by option-click) and then select	a rectangular	area of the screen which includes all of the area to be filled. Finally,	(with crosshair cursor), the user points at the interior of some region	to be	filled, and the filling begins with that place as its seed."	| f r interiorPoint |	Form exampleSketch.	"sketch a little area with an enclosed region"	r := Rectangle fromUser.	f := Form fromDisplay: r.	interiorPoint := Cursor crossHair				showWhile: [Sensor waitButton - r origin].	Cursor execute		showWhile: [f shapeFill: Color gray interiorPoint: interiorPoint].	f displayOn: Display at: r origin! !!Form class methodsFor: 'examples'!makeStar	"See the similar example in OpaqueForm"	| sampleForm pen |	sampleForm := Form extent: 50 @ 50.	"Make a form"	pen := Pen newOnForm: sampleForm.	pen place: 24 @ 50;		 turn: 18.	"Draw a 5-pointed star on it."	1		to: 5		do: [:i | pen go: 19;				 turn: 72;				 go: 19;				 turn: -144].	^ sampleForm"	Form makeStar follow: [Sensor cursorPoint]	while: [Sensor noButtonPressed	"! !!Form class methodsFor: 'examples' stamp: 'tpr 3/15/2013 12:30'!toothpaste: diam 	"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors := Display depth = 1				ifTrue: [Array with: Color black]				ifFalse: [Color red wheel: 12].	facade := Form extent: diam @ diam offset: (diam // -2) asPoint.	(Form dotOfSize: diam)		displayOn: facade		at: (diam // 2) asPoint		clippingBox: facade boundingBox		rule: Form under		fillColor: Color white.	#(1 2 3 )		do: [:x | "simulate facade by circles of gray"			(Form dotOfSize: x * diam // 5)				displayOn: facade				at: (diam * 2 // 5) asPoint				clippingBox: facade boundingBox				rule: Form under				fillColor: (Color						perform: (#(#black #gray #lightGray ) at: x))].	ball := Form dotOfSize: diam.	color := 8.	[port := BitBlt toForm: Display.	"Expand 1-bit forms to any pixel depth"	port		colorMap: (Bitmap with: 0 with: 4294967295).	queue := OrderedCollection new: 32.	16		timesRepeat: [queue addLast: -20 @ -20].	Sensor waitButton.	Sensor yellowButtonPressed		ifTrue: [^ self].	filter := Sensor cursorPoint.	colr := colors atWrap: (color := color + 5).	"choose increment relatively prime to colors size"	colr2 := colr alphaMixed: 0.3 with: Color white.	[Sensor redButtonPressed		or: [queue size > 0]]		whileTrue: [filter := filter * 4 + Sensor cursorPoint // 5.			point := Sensor redButtonPressed						ifTrue: [filter]						ifFalse: [-20 @ -20].			port				copyForm: ball				to: point				rule: Form paint				fillColor: colr.			(q := queue removeFirst) == nil				ifTrue: [^ self].			"exit"			Display depth = 1				ifTrue: [port						copyForm: facade						to: q						rule: Form erase]				ifFalse: [port						copyForm: facade						to: q						rule: Form paint						fillColor: colr2].			Sensor redButtonPressed				ifTrue: [queue addLast: point]]] repeat! !!Form class methodsFor: 'examples' stamp: 'nice 12/29/2010 16:55'!xorHack: size 	"Display restoreAfter: [Form xorHack: 256]"	"Draw a smiley face or stick figure, and end with option-click.	Thereafter image gets 'processed' as long as you have button down.	If you stop at just the right time, you'll see you figure upside down,	and at the end of a full cycle, you'll see it perfectly restored.	Dude -- this works in color too!!"	| rect form i bb |	rect := 5 @ 5 extent: size @ size.	Display fillWhite: rect;				border: (rect expandBy: 2)		width: 2.	Display		border: (rect topRight - (0 @ 2) extent: rect extent * 2 + 4)		width: 2.	Form exampleSketch.	form := Form fromDisplay: rect.	bb := form boundingBox.	i := 0.	[Sensor yellowButtonPressed]		whileFalse: [[Sensor redButtonPressed]				whileTrue: [i := i + 1.					(Array						with: 0 @ 1						with: 0 @ -1						with: 1 @ 0						with: -1 @ 0)						do: [:d | form								copyBits: bb								from: form								at: d								clippingBox: bb								rule: Form reverse								fillColor: nil].					form displayAt: rect topLeft.					i + 2 \\ size < 4						ifTrue: [(Delay forMilliseconds: 300) wait]].			(form magnify: form boundingBox by: 2 @ 2)				displayAt: rect topRight + (2 @ 0).			Sensor waitButton]! !!Form class methodsFor: 'file list services' stamp: 'nk 6/12/2004 12:56'!fileReaderServicesForDirectory: aFileDirectory 	^ {self serviceImageImportDirectory. self serviceImageImportDirectoryWithSubdirectories}! !!Form class methodsFor: 'file list services' stamp: 'nk 7/16/2003 18:01'!fileReaderServicesForFile: fullName suffix: suffix 	^ ((ImageReadWriter allTypicalFileExtensions add: '*';			 add: 'form';			 yourself) includes: suffix)		ifTrue: [self services]		ifFalse: [#()]! !!Form class methodsFor: 'file list services' stamp: 'mt 7/13/2016 11:40'!importImageAndShowImports: fullName 	self importImage: fullName.	Imports default explore! !!Form class methodsFor: 'file list services' stamp: 'hg 8/3/2000 16:26'!openAsBackground: fullName 	"Set an image as a background image. Support Squeak's common file	format 	(GIF, JPG, PNG, 'Form stoteOn: (run coded)' and BMP)"	(self fromFileNamed: fullName) setAsBackground! !!Form class methodsFor: 'file list services' stamp: 'dtl 2/10/2010 15:30'!openImageInWindow: fullName 	"Handle five file formats: GIF, JPG, PNG, Form storeOn: (run coded),	and BMP.	Fail if file format is not recognized."	| image myStream |	myStream := (FileStream readOnlyFileNamed: fullName) binary.	[image := self fromBinaryStream: myStream.	Project current		openImage: image		name: fullName		saveResource: true]		ensure: [myStream close]! !!Form class methodsFor: 'file list services' stamp: 'sw 2/17/2002 01:38'!serviceImageAsBackground	"Answer a service for setting the desktop background from a given	graphical file's contents"	^ SimpleServiceEntry		provider: self		label: 'use graphic as background'		selector: #openAsBackground:		description: 'use the graphic as the background for the desktop'		buttonLabel: 'background'! !!Form class methodsFor: 'file list services' stamp: 'mt 8/10/2016 10:02'!serviceImageImportAndShowImports	"Answer a service for reading a graphic into ImageImports"	^ SimpleServiceEntry		provider: self		label: 'read graphic into and show ImageImports'		selector: #importImageAndShowImports:		description: 'Load a graphic, placing it in the ImageImports repository and browse that repository.'		buttonLabel: 'import'! !!Form class methodsFor: 'file list services' stamp: 'nk 6/12/2004 13:16'!serviceImageImportDirectory	"Answer a service for reading a graphic into ImageImports"	^ (SimpleServiceEntry		provider: self		label: 'import all images from this directory'		selector: #importImageDirectory:		description: 'Load all graphics found in this directory, adding them to the ImageImports repository.'		buttonLabel: 'import dir')		argumentGetter: [:fileList | fileList directory];		 yourself! !!Form class methodsFor: 'file list services' stamp: 'nk 6/12/2004 13:15'!serviceImageImportDirectoryWithSubdirectories	"Answer a service for reading all graphics from a directory and its	subdirectories into ImageImports"	^ (SimpleServiceEntry		provider: self		label: 'import all images from here and subdirectories'		selector: #importImageDirectoryWithSubdirectories:		description: 'Load all graphics found in this directory and its subdirectories, adding them to the ImageImports repository.'		buttonLabel: 'import subdirs')		argumentGetter: [:fileList | fileList directory];		 yourself! !!Form class methodsFor: 'file list services' stamp: 'sw 2/17/2002 01:39'!serviceImageImports	"Answer a service for reading a graphic into ImageImports"	^ SimpleServiceEntry		provider: self		label: 'read graphic into ImageImports'		selector: #importImage:		description: 'Load a graphic, placing it in the ImageImports repository.'		buttonLabel: 'import'! !!Form class methodsFor: 'file list services' stamp: 'sw 2/17/2002 00:31'!serviceOpenImageInWindow	"Answer a service for opening a graphic in a window"	^ SimpleServiceEntry		provider: self		label: 'open graphic in a window'		selector: #openImageInWindow:		description: 'open a graphic file in a window'		buttonLabel: 'open'! !!Form class methodsFor: 'file list services' stamp: 'mt 8/10/2016 10:02'!services	^ Array		with: self serviceImageImports		with: self serviceImageImportAndShowImports		with: self serviceOpenImageInWindow		with: self serviceImageAsBackground! !!Form class methodsFor: 'fileIn/Out' stamp: 'nk 6/12/2004 12:47'!importImage: fullName 	"Import the given image file and store the resulting Form in the default	Imports. The image is named with the short filename up to the first	period, possibly with additions from the directory path to make it	unique. "	Imports default importImageFromFileNamed: fullName! !!Form class methodsFor: 'fileIn/Out' stamp: 'nk 6/12/2004 13:08'!importImageDirectory: dir 	"Import the given image file and store the resulting Form in the default	Imports. The image is named with the short filename up to the first	period, possibly with additions from the directory path to make it	unique. "	Imports default importImageDirectory: dir! !!Form class methodsFor: 'fileIn/Out' stamp: 'nk 6/12/2004 12:55'!importImageDirectoryWithSubdirectories: dir 	"Import the given image file and store the resulting Form in the default	Imports. The image is named with the short filename up to the first	period, possibly with additions from the directory path to make it	unique. "	Imports default importImageDirectoryWithSubdirectories: dir! !!Form class methodsFor: 'initialize-release' stamp: 'ar 9/5/2010 09:09'!initialize	FileServices registerFileReader: self! !!Form class methodsFor: 'instance creation' stamp: 'tpr 3/15/2013 12:30'!dotOfSize: diameter 	"Create a form which contains a round black dot."	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |	radius := diameter // 2.	form := self extent: diameter @ diameter offset: 0 @ 0 - (radius @ radius).	bb := (BitBlt toForm: form) sourceX: 0;				 sourceY: 0;				 combinationRule: Form over;				 fillColor: Color black.	rect := form boundingBox.	centerX := rect center x.	centerY := rect center y.	centerYBias := rect height odd				ifTrue: [0]				ifFalse: [1].	centerXBias := rect width odd				ifTrue: [0]				ifFalse: [1].	radiusSquared := (rect height asFloat / 2.0) squared - 0.01.	xOverY := rect width asFloat / rect height asFloat.	maxy := rect height - 1 // 2.	"First do the inner fill, and collect x values"	0		to: maxy		do: [:dy | 			dx := ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.			bb				destX: centerX - centerXBias - dx				destY: centerY - centerYBias - dy				width: dx + dx + centerXBias + 1				height: 1;				 copyBits.			bb destY: centerY + dy;				 copyBits].	^ form"	Time millisecondsToRun:	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]	"! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:27'!extent: extentPoint 	"Answer an instance of me with a blank bitmap of depth 1."	^ self extent: extentPoint depth: 1! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:36'!extent: extentPoint depth: bitsPerPixel 	"Answer an instance of me with blank bitmap of the given dimensions	and depth."	^ self basicNew setExtent: extentPoint depth: bitsPerPixel! !!Form class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 23:44'!extent: extentPoint depth: bitsPerPixel bits: aBitmap 	"Answer an instance of me with blank bitmap of the given dimensions	and depth."	^ self basicNew		setExtent: extentPoint		depth: bitsPerPixel		bits: aBitmap! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:35'!extent: extentPoint depth: bitsPerPixel fromArray: anArray offset: offsetPoint 	"Answer an instance of me with a pixmap of the given depth initialized	from anArray."	^ (self extent: extentPoint depth: bitsPerPixel) offset: offsetPoint;		 initFromArray: anArray! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:33'!extent: extentPoint fromArray: anArray offset: offsetPoint 	"Answer an instance of me of depth 1 with bitmap initialized from	anArray. "	^ (self extent: extentPoint depth: 1) offset: offsetPoint;		 initFromArray: anArray! !!Form class methodsFor: 'instance creation' stamp: 'nice 12/27/2009 05:15'!extent: extentPoint fromStipple: fourNibbles 	"Answer an instance of me with bitmap initialized from	a repeating 4x4 bit stipple encoded in a 16-bit constant."	^ (self extent: extentPoint depth: 1)		initFromArray: ((1 to: 4)				collect: [:i | 					| nibble |					nibble := (fourNibbles bitShift: -4 * (4 - i))								bitAnd: 15.					286331153 * nibble])"fill 32 bits with each 4-bit nibble"! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:26'!extent: extentPoint offset: offsetPoint 	"Answer an instance of me with a blank bitmap of depth 1."	^ (self extent: extentPoint depth: 1)		offset: offsetPoint! !!Form class methodsFor: 'instance creation' stamp: 'nk 7/7/2003 18:19'!fromBinaryStream: aBinaryStream 	"Read a Form or ColorForm from given file, using the first byte of the	file to guess its format. Currently handles: GIF, uncompressed BMP,	and both old and new DisplayObject writeOn: formats, JPEG, and PCX.	Return nil if the file could not be read or was of an unrecognized	format. "	| firstByte |	aBinaryStream binary.	firstByte := aBinaryStream next.	firstByte = 1		ifTrue: ["old Squeakform format"			^ self new readFromOldFormat: aBinaryStream].	firstByte = 2		ifTrue: ["new Squeak form format"			^ self new readFrom: aBinaryStream].	"Try for JPG, GIF, or PCX..."	"Note: The following call closes the stream."	^ ImageReadWriter formFromStream: aBinaryStream! !!Form class methodsFor: 'instance creation'!fromDisplay: aRectangle 	"Answer an instance of me with bitmap initialized from the area of the 	display screen defined by aRectangle."	^ (self extent: aRectangle extent depth: Display depth)		fromDisplay: aRectangle! !!Form class methodsFor: 'instance creation'!fromDisplay: aRectangle using: oldForm 	"Like fromDisplay: only if oldForm is the right size, copy into it and	answer it instead."	(oldForm ~~ nil			and: [oldForm extent = aRectangle extent])		ifTrue: [oldForm fromDisplay: aRectangle.			^ oldForm]		ifFalse: [^ self fromDisplay: aRectangle]! !!Form class methodsFor: 'instance creation' stamp: 'mir 11/19/2001 14:13'!fromFileNamed: fileName 	"Read a Form or ColorForm from the given file."	| file form |	file := (FileStream readOnlyFileNamed: fileName) binary.	form := self fromBinaryStream: file.	Smalltalk isMorphic		ifTrue: [Project current resourceManager addResource: form url: (FileDirectory urlForFileNamed: file name) asString].	file close.	^ form! !!Form class methodsFor: 'instance creation'!fromUser	"Answer an instance of me with bitmap initialized from the area of the 	display screen designated by the user. The grid for selecting an area	is 	1@1."	^ self fromUser: 1 @ 1! !!Form class methodsFor: 'instance creation' stamp: 'ar 3/1/2006 22:50'!fromUser: gridPoint 	"Answer an instance of me with bitmap initialized from the area of the 	display screen designated by the user. The grid for selecting an area	is 	aPoint. Ensures that the returned form has positive extent."	| rect |	rect := Rectangle fromUser: gridPoint.	^ self		fromDisplay: (rect origin				extent: (rect extent max: gridPoint))! !!Form class methodsFor: 'instance creation' stamp: 'jm 12/5/97 19:32'!fromUserWithExtent: anExtent 	"Answer an instance of me with bitmap initialized from the area of the 	display screen whose origin is designated by the user and whose size	is anExtent"	^ self		fromDisplay: (Rectangle originFromUser: anExtent)"(Form fromUserWithExtent: 50@50) displayAt: 10@10"! !!Form class methodsFor: 'mode constants'!and	"Answer the integer denoting the logical 'and' combination rule."	^ 1! !!Form class methodsFor: 'mode constants'!blend	"Answer the integer denoting BitBlt's alpha blend combination rule."	^ 24! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!blendAlpha	"Answer the integer denoting BitBlt's blend-with-constant-alpha rule."	^ 30! !!Form class methodsFor: 'mode constants' stamp: 'mt 11/16/2010 20:31'!blendAlphaScaled	"Answer the integer denoting BitBlt's blend-with-alpha-scaled rule."	^ 34! !!Form class methodsFor: 'mode constants' stamp: 'tpr 11/13/2015 15:35'!compareMatchColor	"The primCompare test id values are	compareMatchColors -> 0	compareNotColorANotColorB -> 1	compareNotColorAMatchColorB -> 2"	^ 0! !!Form class methodsFor: 'mode constants' stamp: 'tpr 11/13/2015 15:35'!compareNotColorAMatchColorB	"The primCompare test id values are	compareMatchColors -> 0	compareNotColorANotColorB -> 1	compareNotColorAMatchColorB -> 2"	^ 2! !!Form class methodsFor: 'mode constants' stamp: 'tpr 11/13/2015 15:35'!compareNotColorANotColorB	"The primCompare test id values are	compareMatchColors -> 0	compareNotColorANotColorB -> 1	compareNotColorAMatchColorB -> 2"	^ 1! !!Form class methodsFor: 'mode constants' stamp: 'tpr 11/13/2015 15:36'!compareTallyFlag	"The primCompare test id values are ORR'd with 8 to indicate tallying	rather than simply reporting the first hit"	^ 8! !!Form class methodsFor: 'mode constants'!erase	"Answer the integer denoting mode erase."	^ 4! !!Form class methodsFor: 'mode constants'!erase1bitShape	"Answer the integer denoting mode erase."	^ 26! !!Form class methodsFor: 'mode constants'!oldErase1bitShape	"Answer the integer denoting mode erase."	^ 17! !!Form class methodsFor: 'mode constants'!oldPaint	"Answer the integer denoting the 'paint' combination rule."	^ 16! !!Form class methodsFor: 'mode constants'!over	"Answer the integer denoting mode over."	^ 3! !!Form class methodsFor: 'mode constants'!paint	"Answer the integer denoting the 'paint' combination rule."	^ 25! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!paintAlpha	"Answer the integer denoting BitBlt's paint-with-constant-alpha rule."	^ 31! !!Form class methodsFor: 'mode constants'!reverse	"Answer the integer denoting mode reverse."	^ 6! !!Form class methodsFor: 'mode constants' stamp: 'hg 1/29/2001 17:28'!rgbMul	"Answer the integer denoting 'Multiply each color component, 	their values regarded as fractions of 1' rule."	^ 37! !!Form class methodsFor: 'mode constants'!under	"Answer the integer denoting mode under."	^ 7! !!Form class methodsFor: 'shut down' stamp: 'ar 5/28/2000 23:35'!shutDown	"Form shutDown"	"Compress all instances in the system. Will decompress on demand..."	Form		allInstancesDo: [:f | f hibernate].	ColorForm		allInstancesDo: [:f | f hibernate]! !Form initialize!