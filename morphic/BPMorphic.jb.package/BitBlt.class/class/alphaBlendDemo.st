examples
alphaBlendDemo	"To run this demo, use...	Display restoreAfter: [BitBlt alphaBlendDemo]		Displays 10 alphas, then lets you paint. Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk	3/10/97 "	"This version uses a sliding buffer for painting that keeps pixels in 32	bits as long as they are in the buffer, so as not to lose info by	converting down	to display resolution and back up to 32 bits at each operation. - di	3/15/97 "	"compute color maps if needed"	| _gsSqueakTemp_brush _gsSqueakTemp_buff _gsSqueakTemp_dispToBuff _gsSqueakTemp_buffToDisplay _gsSqueakTemp_mapDto32 _gsSqueakTemp_map32toD _gsSqueakTemp_prevP _gsSqueakTemp_p _gsSqueakTemp_brushToBuff _gsSqueakTemp_theta _gsSqueakTemp_buffRect _gsSqueakTemp_buffSize _gsSqueakTemp_buffToBuff _gsSqueakTemp_brushRect _gsSqueakTemp_delta _gsSqueakTemp_newBuffRect _gsSqueakTemp_updateRect |	Display depth <= 8		ifTrue: [_gsSqueakTemp_mapDto32 := Color cachedColormapFrom: Display depth to: 32.			_gsSqueakTemp_map32toD := Color cachedColormapFrom: 32 to: Display depth].	"display 10 different alphas, across top of screen"	_gsSqueakTemp_buff := Form extent: 500 @ 50 depth: 32.	_gsSqueakTemp_dispToBuff := BitBlt toForm: _gsSqueakTemp_buff.	_gsSqueakTemp_dispToBuff colorMap: _gsSqueakTemp_mapDto32.	_gsSqueakTemp_dispToBuff		copyFrom: (50 @ 10 extent: 500 @ 50)		in: Display		to: 0 @ 0.	1		to: 10		do: [:i | _gsSqueakTemp_dispToBuff				fill: (50 * (i - 1) @ 0 extent: 50 @ 50)				fillColor: (Color red alpha: i / 10)				rule: Form blend].	_gsSqueakTemp_buffToDisplay := BitBlt toForm: Display.	_gsSqueakTemp_buffToDisplay colorMap: _gsSqueakTemp_map32toD.	_gsSqueakTemp_buffToDisplay		copyFrom: _gsSqueakTemp_buff boundingBox		in: _gsSqueakTemp_buff		to: 50 @ 10.	"Create a brush with radially varying alpha"	_gsSqueakTemp_brush := Form extent: 30 @ 30 depth: 32.	1		to: 5		do: [:i | _gsSqueakTemp_brush				fillShape: (Form dotOfSize: _gsSqueakTemp_brush width * (6 - i) // 5)				fillColor: (Color red alpha: 0.02 * i - 0.01)				at: _gsSqueakTemp_brush extent // 2].	"Now paint with the brush using alpha blending."	_gsSqueakTemp_buffSize := 100.	_gsSqueakTemp_buff := Form extent: _gsSqueakTemp_brush extent + _gsSqueakTemp_buffSize depth: 32.	"Travelling 32-bit buffer"	_gsSqueakTemp_dispToBuff := BitBlt toForm: _gsSqueakTemp_buff.	"This is from Display to buff"	_gsSqueakTemp_dispToBuff colorMap: _gsSqueakTemp_mapDto32.	_gsSqueakTemp_brushToBuff := BitBlt toForm: _gsSqueakTemp_buff.	"This is from brush to buff"	_gsSqueakTemp_brushToBuff sourceForm: _gsSqueakTemp_brush;		 sourceOrigin: 0 @ 0.	_gsSqueakTemp_brushToBuff combinationRule: Form blend.	_gsSqueakTemp_buffToBuff := BitBlt toForm: _gsSqueakTemp_buff.	"This is for slewing the buffer"	[Sensor yellowButtonPressed]		whileFalse: [_gsSqueakTemp_prevP := nil.			_gsSqueakTemp_buffRect := Sensor cursorPoint - (_gsSqueakTemp_buffSize // 2) extent: _gsSqueakTemp_buff extent.			_gsSqueakTemp_dispToBuff				copyFrom: _gsSqueakTemp_buffRect				in: Display				to: 0 @ 0.			[Sensor redButtonPressed]				whileTrue: ["Here is the painting loop"					_gsSqueakTemp_p := Sensor cursorPoint - (_gsSqueakTemp_brush extent // 2).					(_gsSqueakTemp_prevP == nil							or: [_gsSqueakTemp_prevP ~= _gsSqueakTemp_p])						ifTrue: [_gsSqueakTemp_prevP == nil								ifTrue: [_gsSqueakTemp_prevP := _gsSqueakTemp_p].							(_gsSqueakTemp_p dist: _gsSqueakTemp_prevP)									> _gsSqueakTemp_buffSize								ifTrue: ["Stroke too long to fit in buffer -- clip to									buffer, and next time through will do									more of it"									_gsSqueakTemp_theta := (_gsSqueakTemp_p - _gsSqueakTemp_prevP) theta.									_gsSqueakTemp_p := (_gsSqueakTemp_theta cos @ _gsSqueakTemp_theta sin * _gsSqueakTemp_buffSize asFloat + _gsSqueakTemp_prevP) truncated].							_gsSqueakTemp_brushRect := _gsSqueakTemp_p extent: _gsSqueakTemp_brush extent.							(_gsSqueakTemp_buffRect containsRect: _gsSqueakTemp_brushRect)								ifFalse: ["Brush is out of buffer region. Scroll the									buffer, and fill vacated regions from									the display"									_gsSqueakTemp_delta := _gsSqueakTemp_brushRect amountToTranslateWithin: _gsSqueakTemp_buffRect.									_gsSqueakTemp_buffToBuff										copyFrom: _gsSqueakTemp_buff boundingBox										in: _gsSqueakTemp_buff										to: _gsSqueakTemp_delta.									_gsSqueakTemp_newBuffRect := _gsSqueakTemp_buffRect translateBy: _gsSqueakTemp_delta negated.									(_gsSqueakTemp_newBuffRect areasOutside: _gsSqueakTemp_buffRect)										do: [:r | _gsSqueakTemp_dispToBuff												copyFrom: r												in: Display												to: r origin - _gsSqueakTemp_newBuffRect origin].									_gsSqueakTemp_buffRect := _gsSqueakTemp_newBuffRect].							"Interpolate from prevP to p..."							_gsSqueakTemp_brushToBuff								drawFrom: _gsSqueakTemp_prevP - _gsSqueakTemp_buffRect origin								to: _gsSqueakTemp_p - _gsSqueakTemp_buffRect origin								withFirstPoint: false.							"Update (only) the altered pixels of the							destination "							_gsSqueakTemp_updateRect := (_gsSqueakTemp_p min: _gsSqueakTemp_prevP)										corner: (_gsSqueakTemp_p max: _gsSqueakTemp_prevP)												+ _gsSqueakTemp_brush extent.							_gsSqueakTemp_buffToDisplay								copy: _gsSqueakTemp_updateRect								from: _gsSqueakTemp_updateRect origin - _gsSqueakTemp_buffRect origin								in: _gsSqueakTemp_buff.							_gsSqueakTemp_prevP := _gsSqueakTemp_p]]]