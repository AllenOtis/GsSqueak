'From Squeak5.1 of 15 October 2017 [latest update: #16550] on 16 January 2018 at 3:44:15 pm'!Form subclass: #DisplayScreen	instanceVariableNames: 'clippingBox extraRegions'	classVariableNames: 'DeferringUpdates DisplayChangeSignature DisplayIsFullScreen ScreenSave'	poolDictionaries: ''	category: 'Graphics-Display Objects'!!DisplayScreen commentStamp: '<historical>' prior: 0!There is only one instance of me, Display. It is a global and is used to handle general user requests to deal with the whole display screen. 	Although I offer no protocol, my name provides a way to distinguish this special instance from all other Forms. This is useful, for example, in dealing with saving and restoring the system.	To change the depth of your Display...		Display newDepth: 16.		Display newDepth: 8.		Display newDepth: 1.Valid display depths are 1, 2, 4, 8, 16 and 32.  It is suggested that you run with your monitors setting the same, for better speed and color fidelity.  Note that this can add up to 4Mb for the Display form.  Finally, note that newDepth: ends by executing a 'ControlManager restore' which currently terminates the active process, so nothing that follows in the doit will get executed.Depths 1, 2, 4 and 8 bits go through a color map to put color on the screen, but 16 and 32-bit color use the pixel values directly for RGB color (5 and 8 bits per, respectivlely).  The color choice an be observed by executing Color fromUser in whatever depth you are using.!!DisplayScreen methodsFor: '*51Deprecated' stamp: 'mt 5/9/2016 11:17'!newDepthNoRestore: pixelSize 	self deprecated.	self newDepth: pixelSize! !!DisplayScreen methodsFor: '*Morphic-blitter defaults' stamp: 'ar 5/28/2000 12:02'!defaultCanvasClass	"Return the WarpBlt version to use when I am active"	^ FormCanvas! !!DisplayScreen methodsFor: 'blitter defaults' stamp: 'ar 5/28/2000 12:01'!defaultBitBltClass	"Return the BitBlt version to use when I am active"	^ BitBlt! !!DisplayScreen methodsFor: 'blitter defaults' stamp: 'ar 5/28/2000 12:01'!defaultWarpBltClass	"Return the WarpBlt version to use when I am active"	^ WarpBlt! !!DisplayScreen methodsFor: 'disk I/O' stamp: 'tk 9/28/2000 15:41'!objectForDataStream: refStrm 	"I am about to be written on an object file. Write a reference to the	Display in the other system instead. "	"A path to me"	| dp |	dp := DiskProxy				global: #Display				selector: #yourself				args: #().	refStrm replace: self with: dp.	^ dp! !!DisplayScreen methodsFor: 'displaying' stamp: 'ar 4/19/2001 05:44'!addExtraRegion: aRectangle for: regionDrawer 	"Register the given rectangle as a region which is drawn by the	specified region drawer. The region will be excluded from any updates	when #forceDamageToScreen: is called. Note that the rectangle is	only valid for a single update cycle; once #forceDamageToScreen: has	been called, the region drawer and its region are being removed from	the list"	extraRegions		ifNil: [extraRegions := #()].	extraRegions := extraRegions				copyWith: (Array with: regionDrawer with: aRectangle)! !!DisplayScreen methodsFor: 'displaying' stamp: 'tpr 3/15/2013 12:20'!copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf 	(BitBlt		destForm: self		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: rect origin		extent: rect extent		clipRect: (clipRect intersect: clippingBox)) copyBits! !!DisplayScreen methodsFor: 'displaying' stamp: 'tpr 3/15/2013 12:21'!copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf map: map 	((BitBlt		destForm: self		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: rect origin		extent: rect extent		clipRect: (clipRect intersect: clippingBox))		colorMap: map) copyBits! !!DisplayScreen methodsFor: 'displaying' stamp: 'jm 5/22/1998 01:23'!flash: aRectangle 	"Flash the area of the screen defined by the given rectangle."	self reverse: aRectangle.	self forceDisplayUpdate.	(Delay forMilliseconds: 100) wait.	self reverse: aRectangle.	self forceDisplayUpdate! !!DisplayScreen methodsFor: 'displaying' stamp: 'RAA 6/2/2000 12:09'!flash: aRectangle andWait: msecs 	"Flash the area of the screen defined by the given rectangle."	self reverse: aRectangle.	self forceDisplayUpdate.	(Delay forMilliseconds: msecs) wait.	self reverse: aRectangle.	self forceDisplayUpdate.	(Delay forMilliseconds: msecs) wait! !!DisplayScreen methodsFor: 'displaying' stamp: 'sw 1/1/2005 01:31'!flashAll: rectangleList andWait: msecs 	"Flash the areas of the screen defined by the given rectangles."	rectangleList		do: [:aRectangle | self reverse: aRectangle].	self forceDisplayUpdate.	(Delay forMilliseconds: msecs) wait.	rectangleList		do: [:aRectangle | self reverse: aRectangle].	self forceDisplayUpdate.	(Delay forMilliseconds: msecs) wait! !!DisplayScreen methodsFor: 'displaying' stamp: 'nice 12/27/2009 03:10'!forceDamageToScreen: allDamage 	"Force all the damage rects to the screen."	| regions rectList |	rectList := allDamage.	"Note: Reset extra regions at the beginning to prevent repeated errors"	regions := extraRegions.	extraRegions := nil.	regions		ifNotNil: ["exclude extra regions"			regions				do: [:drawerAndRect | 					| excluded remaining |					excluded := drawerAndRect at: 2.					remaining := WriteStream on: #().					rectList						do: [:r | remaining								nextPutAll: (r areasOutside: excluded)].					rectList := remaining contents]].	rectList		do: [:r | self forceToScreen: r].	regions		ifNotNil: ["Have the drawers paint what is needed"			regions				do: [:drawerAndRect | (drawerAndRect at: 1) forceToScreen]]! !!DisplayScreen methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:07'!release	"I am no longer Display. Release any resources if necessary"	^ self! !!DisplayScreen methodsFor: 'initialize-release' stamp: 'ar 5/28/2000 11:25'!shutDown	"Minimize Display memory saved in image"	self setExtent: 240 @ 120 depth: depth! !!DisplayScreen methodsFor: 'other'!boundingBox	clippingBox == nil		ifTrue: [clippingBox := super boundingBox].	^ clippingBox! !!DisplayScreen methodsFor: 'other'!clippingTo: aRect do: aBlock 	"Display clippingTo: Rectangle fromUser do:	[ScheduledControllers restore: Display fullBoundingBox]"	| saveClip |	saveClip := clippingBox.	clippingBox := aRect.	aBlock value.	clippingBox := saveClip! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 6/18/2000 19:16'!deferUpdates: aBoolean 	"Set the deferUpdates flag in the virtual machine. When this flag is	true, BitBlt operations on the Display are not automatically	propagated to the screen. If this underlying platform does not	support deferred updates, this primitive will fail. Answer whether	updates were deferred before if the primitive succeeds, nil if it fails."	| wasDeferred |	wasDeferred := DeferringUpdates == true.	DeferringUpdates := aBoolean.	^ (self primitiveDeferUpdates: aBoolean)		ifNotNil: [wasDeferred]! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 2/2/2001 10:14'!deferUpdatesIn: aRectangle while: aBlock 	| result |	(self deferUpdates: true)		ifTrue: [^ aBlock value].	result := aBlock value.	self deferUpdates: false.	self forceToScreen: aRectangle.	^ result! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 11/27/1999 15:48'!displayChangeSignature	^ DisplayChangeSignature! !!DisplayScreen methodsFor: 'other' stamp: 'jm 5/21/1998 23:48'!forceDisplayUpdate	"On platforms that buffer screen updates, force the screen to be	updated immediately. On other platforms, or if the primitive is not	implemented, do nothing."	"do nothing if primitive fails"	self halt.	^ self! !!DisplayScreen methodsFor: 'other' stamp: 'ar 2/11/1999 18:14'!forceToScreen	"Force the entire display area to the screen"	^ self forceToScreen: self boundingBox! !!DisplayScreen methodsFor: 'other' stamp: 'jm 5/19/1998 17:50'!forceToScreen: aRectangle 	"Force the given rectangular section of the Display to be copied to the	screen. The primitive call does nothing if the primitive is not	implemented. Typically used when the deferUpdates flag in the virtual	machine is on; see deferUpdates:."	self		primShowRectLeft: aRectangle left		right: aRectangle right		top: aRectangle top		bottom: aRectangle bottom! !!DisplayScreen methodsFor: 'other'!fullBoundingBox	^ super boundingBox! !!DisplayScreen methodsFor: 'other'!fullScreen	"Display fullScreen"	ScreenSave notNil		ifTrue: [Display := ScreenSave].	clippingBox := super boundingBox! !!DisplayScreen methodsFor: 'other' stamp: 'sd 6/7/2003 19:46'!fullScreenMode: aBoolean 	"On platforms that support it, set full-screen mode to the value of the	argument. (Note: you'll need to restore the Display after calling this	primitive. "	"Display fullScreenMode: true. Display newDepth: Display depth"	self halt.	self primitiveFailed! !!DisplayScreen methodsFor: 'other'!height	^ self boundingBox height! !!DisplayScreen methodsFor: 'other' stamp: 'mt 5/9/2016 11:16'!newDepth: pixelSize 	"	Display newDepth: 8.	Display newDepth: 1	"	| area need |	(self supportsDisplayDepth: pixelSize)		ifFalse: [^ self inform: 'Display depth ' , pixelSize printString , ' is not supported on this system'].	pixelSize = self depth		ifTrue: [^ self"no change"].	pixelSize abs < self depth		ifFalse: ["Make sure there is enough space"			area := self boundingBox area.			"pixels"			need := area * (pixelSize abs - self depth) // 8 + Smalltalk lowSpaceThreshold.			"new bytes needed"			(Smalltalk garbageCollectMost <= need					and: [Smalltalk garbageCollect <= need])				ifTrue: [self error: 'Insufficient free space']].	Display setExtent: Display extent depth: pixelSize.	Display beDisplay.	Project current		ifNotNil: [:p | p displayDepthChanged; displaySizeChanged]! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 6/18/2000 19:14'!primitiveDeferUpdates: aBoolean 	"Set the deferUpdates flag in the virtual machine. When this flag is	true, BitBlt operations on the Display are not automatically	propagated to the screen. If this underlying platform does not	support deferred updates, this primitive will fail. Answer the receiver if	the primitive succeeds, nil if it fails."	self halt.	^ nil"answer nil if primitive fails"! !!DisplayScreen methodsFor: 'other'!replacedBy: aForm do: aBlock 	"Permits normal display to draw on aForm instead of the display."	ScreenSave := self.	Display := aForm.	aBlock value.	Display := self.	ScreenSave := nil! !!DisplayScreen methodsFor: 'other' stamp: 'mt 5/9/2016 10:46'!restore	DisplayScreen startUp.	Project current		ifNotNil: [:p | p displaySizeChanged]! !!DisplayScreen methodsFor: 'other' stamp: 'mt 5/9/2016 10:57'!restoreAfter: aBlock 	"Evaluate the block, wait for a mouse click, and then restore the	screen. "	aBlock		ensure: [Sensor waitButton.			self restore]! !!DisplayScreen methodsFor: 'other' stamp: 'ar 5/17/2001 21:02'!supportedDisplayDepths	"Return all pixel depths supported on the current host platform."	^ #(1 2 4 8 16 32 -1 -2 -4 -8 -16 -32 )		select: [:d | self supportsDisplayDepth: d]! !!DisplayScreen methodsFor: 'other' stamp: 'ar 5/5/1999 23:45'!supportsDisplayDepth: pixelDepth 	"Return true if this pixel depth is supported on the current host	platform. Primitive. Optional."	self halt.	^ #(1 2 4 8 16 32 ) includes: pixelDepth! !!DisplayScreen methodsFor: 'other'!usableArea	"Answer the usable area of the receiver. 5/22/96 sw."	^ self boundingBox deepCopy! !!DisplayScreen methodsFor: 'other'!width	^ self boundingBox width! !!DisplayScreen methodsFor: 'testing' stamp: 'ar 5/25/2000 23:34'!isDisplayScreen	^ true! !!DisplayScreen methodsFor: 'private'!beDisplay	"Primitive. Tell the interpreter to use the receiver as the current display	image. Fail if the form is too wide to fit on the physical display. 	Essential. See Object documentation whatIsAPrimitive."	self halt.	self primitiveFailed! !!DisplayScreen methodsFor: 'private' stamp: 'di 3/3/1999 10:00'!copyFrom: aForm 	"Take on all state of aForm, with complete sharing"	super copyFrom: aForm.	clippingBox := super boundingBox! !!DisplayScreen methodsFor: 'private' stamp: 'jrd 5/23/2009 00:53'!findAnyDisplayDepth	"Return any display depth that is supported on this system."	^ self		findAnyDisplayDepthIfNone: ["Ugh .... now this is a biggie - a system that does not support			any of the Squeak display depths at all."			Smalltalk logSqueakError: 'Fatal error: This system has no support for any display depth at all.' inContext: thisContext.			Smalltalk quitPrimitive]! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/17/2001 21:03'!findAnyDisplayDepthIfNone: aBlock 	"Return any display depth that is supported on this system.	If there is none, evaluate aBlock."	#(1 2 4 8 16 32 -1 -2 -4 -8 -16 -32 )		do: [:bpp | (self supportsDisplayDepth: bpp)				ifTrue: [^ bpp]].	^ aBlock value! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:00'!primRetryShowRectLeft: l right: r top: t bottom: b 	"Copy the given rectangular section of the Display to to the screen.	This primitive is not implemented on all platforms. Do nothing if it	fails. "	"do nothing if primitive fails"	self halt.	^ self! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:02'!primShowRectLeft: l right: r top: t bottom: b 	"Copy the given rectangular section of the Display to to the screen.	This primitive is not implemented on all platforms. If this fails, retry	integer coordinates."	"if this fails, coerce coordinates to integers and try again"	self halt.	self		primRetryShowRectLeft: l truncated		right: r rounded		top: t truncated		bottom: b rounded! !!DisplayScreen methodsFor: 'private' stamp: 'bf 5/16/2006 11:35'!setExtent: aPoint depth: bitsPerPixel 	"DisplayScreen startUp"	"This method is critical. If the setExtent fails, there will be no	proper display on which to show the error condition..."	"ar 5/1/1999: ... and that is exactly why we check for the available	display depths first."	"RAA 27 Nov 99 - if depth and extent are the same and acceptable,	why go through this.	also - record when we change so worlds can tell if it is time to repaint"	(depth == bitsPerPixel			and: [aPoint = self extent					and: [self supportsDisplayDepth: bitsPerPixel]])		ifFalse: [bits := nil.			"Free up old bitmap in case space is low"			DisplayChangeSignature := (DisplayChangeSignature						ifNil: [0])						+ 1.			(self supportsDisplayDepth: bitsPerPixel)				ifTrue: [super setExtent: aPoint depth: bitsPerPixel]				ifFalse: [(self supportsDisplayDepth: bitsPerPixel negated)						ifTrue: [super setExtent: aPoint depth: bitsPerPixel negated]						ifFalse: ["Search for a suitable depth"							super setExtent: aPoint depth: self findAnyDisplayDepth]]].	clippingBox := super boundingBox! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DisplayScreen class	instanceVariableNames: ''!!DisplayScreen class methodsFor: '*51Deprecated' stamp: 'wiz 5/10/2008 19:46'!depth: depthInteger width: widthInteger height: heightInteger fullscreen: aBoolean 	"Force Squeak's window (if there's one) into a new size and depth."	"DisplayScreen depth: 8 width: 1024 height: 768 fullscreen: false"	self halt.	self primitiveFailed! !!DisplayScreen class methodsFor: 'display box access'!boundingBox	"Answer the bounding box for the form representing the current	display 	screen."	^ Display boundingBox! !!DisplayScreen class methodsFor: 'display box access' stamp: 'mt 5/9/2016 10:47'!checkForNewScreenSize	"Check whether the screen size has changed and if so take appropriate	actions "	Display extent = DisplayScreen actualScreenSize		ifFalse: [Display restore]! !!DisplayScreen class methodsFor: 'display box access' stamp: 'mt 8/19/2016 08:40'!setNewScreenSize: aPoint 	"Ensure that the Display is set to the given extent."	self hostWindowExtent: aPoint.	self checkForNewScreenSize.	"In the Windows version of the host window plugin, the extent	currently includes window decorations. Therefore, we need two	attempts to ensure that the Display extent is aPoint. Note that this is	a bug in the plugin."	(Display extent x < aPoint x			or: [Display extent y < aPoint y])		ifTrue: [self hostWindowExtent: 2 * aPoint - Display extent.			self checkForNewScreenSize]! !!DisplayScreen class methodsFor: 'host window access' stamp: 'mt 5/7/2016 09:37'!hostWindowExtent: aPoint 	^ self		primitiveWindow: self hostWindowIndex		width: aPoint x		height: aPoint y! !!DisplayScreen class methodsFor: 'host window access' stamp: 'dtl 5/11/2016 22:33'!hostWindowIndex	"By convention, the reference to the primary Squeak display window is	1. The host window plugin may use different conventions for	references to	windows. In general, the handles for references to host windows	should be	considered as meaningful only to the VM plugin, with host window	index 1	being a special case of a well known handle value."	^ 1! !!DisplayScreen class methodsFor: 'host window access' stamp: 'mt 5/7/2016 09:33'!hostWindowTitle: aString 	^ self primitiveWindow: self hostWindowIndex title: aString squeakToUtf8! !!DisplayScreen class methodsFor: 'primitives - host window access' stamp: 'mt 5/7/2016 09:30'!primitiveWindow: id title: titleString 	self halt.	^ self primitiveFailed! !!DisplayScreen class methodsFor: 'primitives - host window access' stamp: 'mt 5/7/2016 09:30'!primitiveWindow: id width: width height: height 	self halt.	^ self primitiveFailed! !!DisplayScreen class methodsFor: 'screen modes' stamp: 'mt 5/6/2016 15:20'!displayIsFullScreen	^ DisplayIsFullScreen		ifNil: [DisplayIsFullScreen := false]! !!DisplayScreen class methodsFor: 'screen modes' stamp: 'mt 5/6/2016 15:17'!fullScreenOff	Display fullScreenMode: (DisplayIsFullScreen := false).	self checkForNewScreenSize! !!DisplayScreen class methodsFor: 'screen modes' stamp: 'mt 5/6/2016 15:17'!fullScreenOn	Display fullScreenMode: (DisplayIsFullScreen := true).	self checkForNewScreenSize! !!DisplayScreen class methodsFor: 'screen modes' stamp: 'mt 5/6/2016 15:20'!toggleFullScreen	"Toggle between full screen and windowed mode."	self displayIsFullScreen		ifTrue: [self fullScreenOff]		ifFalse: [self fullScreenOn]! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'ar 2/5/2001 17:24'!actualScreenDepth	self halt.	^ Display depth! !!DisplayScreen class methodsFor: 'snapshots'!actualScreenSize	self halt.	^ 640 @ 480! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'ar 5/28/2000 11:26'!shutDown	"Minimize Display memory saved in image"	Display shutDown! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'ar 5/17/2001 15:50'!startUp	"DisplayScreen startUp"	Display setExtent: self actualScreenSize depth: Display nativeDepth.	Display beDisplay! !!DisplayScreen class methodsFor: 'testing' stamp: 'tfel 3/3/2016 17:05'!isDeferringUpdates	^ DeferringUpdates == true! !